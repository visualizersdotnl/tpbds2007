<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.7: http://docutils.sourceforge.net/" />
<link rel="stylesheet" href="css/style.css" type="text/css" media="all"  />
<!-- WIN IE Style Sheets -->
<!--[if IE]>
  <![if gte IE 5.5]>
   <![if gte IE 7]><link rel="stylesheet" 
	type="text/css" media="screen,projection" 
	href="css/ie.css" />
	<![endif]>
   <![if lt IE 7]><link rel="stylesheet" 
	type="text/css" media="screen,projection" 
	href="css/ie.css" />
	<![endif]>
  <![endif]>
  <![if lt IE 5.5]>
   <link rel="stylesheet"
	type="text/css" media="screen,projection" 
	href="css/ie.css" />
    <![endif]>
<![endif]-->
<title>Intel® SPMD Program Compiler User's Guide</title>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1486404-4']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></head>
<body>
<div id="wrap">
  <div id="wrap2">
    <div id="header">
      <h1 id="logo">Intel SPMD Program Compiler</h1>
      <div id="slogan">An open-source compiler for high-performance SIMD programming on
      the CPU</div>
    </div>
    <div id="nav">
      <div id="nbar">
        <ul>
          <li id="selected"><a href="index.html">Home</a></li>
          <li><a href="downloads.html">Downloads</a></li>
          <li><a href="example.html">Example</a></li>
          <li><a href="ispc.html">User's Guide</a></li>
        </ul>
      </div>
    </div>
    <div id="content-wrap">
      <div id="sidebar">
          <div class="widgetspace">
            <h1>Resources</h1>
            <ul class="menu">
              <li><a href="http://github.com/ispc/ispc/">ispc page on github</a></li>
              <li><a href="http://groups.google.com/group/ispc-users/">ispc
              users mailing list</a></li>
              <li><a href="http://groups.google.com/group/ispc-dev/">ispc
              developers mailing list</a></li>
              <li><a href="http://github.com/ispc/ispc/wiki/">Wiki</a></li>
              <li><a href="http://github.com/ispc/ispc/issues/">Bug tracking</a></li>
              <li><a href="doxygen/index.html">Doxygen documentation of
              <tt>ispc</tt> source code</a></li>
            </ul>
        </div>
      </div>
      <div id="content">
<h1 class="title">Intel® SPMD Program Compiler User's Guide</h1>

<p><tt class="docutils literal">ispc</tt> is a compiler for writing SPMD (single program multiple data)
programs to run on the CPU.  The SPMD programming approach is widely known
to graphics and GPGPU programmers; it is used for GPU shaders and CUDA* and
OpenCL* kernels, for example.  The main idea behind SPMD is that one writes
programs as if they were operating on a single data element (a pixel for a
pixel shader, for example), but then the underlying hardware and runtime
system executes multiple invocations of the program in parallel with
different inputs (the values for different pixels, for example).</p>
<p>The main goals behind <tt class="docutils literal">ispc</tt> are to:</p>
<ul class="simple">
<li>Build a small C-like language that can deliver good performance to
performance-oriented programmers who want to run SPMD programs on
CPUs.</li>
<li>Provide a thin abstraction layer between the programmer and the
hardware--in particular, to follow the lesson from C for serial programs
of having an execution and data model where the programmer can cleanly
reason about the mapping of their source program to compiled assembly
language and the underlying hardware.</li>
<li>Harness the computational power of the Single Program, Multiple Data (SIMD) vector
units without the extremely low-programmer-productivity activity of directly
writing intrinsics.</li>
<li>Explore opportunities from close-coupling between C/C++ application code
and SPMD <tt class="docutils literal">ispc</tt> code running on the same processor--lightweight funcion
calls betwen the two languages, sharing data directly via pointers without
copying or reformating, etc.</li>
</ul>
<p><tt class="docutils literal">ispc</tt> has already successfully delivered significant speedups for a
number of non-trivial workloads that aren't handled well by other
compilation approaches (e.g. loop auto-vectorization.)</p>
<p>Contents:</p>
<ul class="simple">
<li><a class="reference internal" href="#recent-changes-to-ispc">Recent Changes to ISPC</a></li>
<li><a class="reference internal" href="#getting-started-with-ispc">Getting Started with ISPC</a><ul>
<li><a class="reference internal" href="#installing-ispc">Installing ISPC</a></li>
<li><a class="reference internal" href="#compiling-and-running-a-simple-ispc-program">Compiling and Running a Simple ISPC Program</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-ispc-compiler">Using The ISPC Compiler</a><ul>
<li><a class="reference internal" href="#command-line-options">Command-line Options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-ispc-language">The ISPC Language</a><ul>
<li><a class="reference internal" href="#lexical-structure">Lexical Structure</a></li>
<li><a class="reference internal" href="#basic-types-and-type-qualifiers">Basic Types and Type Qualifiers</a></li>
<li><a class="reference internal" href="#short-vector-types">Short Vector Types</a></li>
<li><a class="reference internal" href="#struct-and-array-types">Struct and Array Types</a></li>
<li><a class="reference internal" href="#declarations-and-initializers">Declarations and Initializers</a></li>
<li><a class="reference internal" href="#function-declarations">Function Declarations</a></li>
<li><a class="reference internal" href="#expressions">Expressions</a></li>
<li><a class="reference internal" href="#control-flow">Control Flow</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#c-constructs-not-in-ispc">C Constructs not in ISPC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#parallel-execution-model-in-ispc">Parallel Execution Model in ISPC</a><ul>
<li><a class="reference internal" href="#the-spmd-on-simd-execution-model">The SPMD-on-SIMD Execution Model</a></li>
<li><a class="reference internal" href="#uniform-and-varying-qualifiers">Uniform and Varying Qualifiers</a></li>
<li><a class="reference internal" href="#mapping-data-to-program-instances">Mapping Data to Program Instances</a></li>
<li><a class="reference internal" href="#coherent-control-flow-statements">&quot;Coherent&quot; Control Flow Statements</a></li>
<li><a class="reference internal" href="#program-instance-convergence">Program Instance Convergence</a></li>
<li><a class="reference internal" href="#data-races">Data Races</a></li>
<li><a class="reference internal" href="#uniform-variables-and-varying-control-flow">Uniform Variables and Varying Control Flow</a></li>
<li><a class="reference internal" href="#task-parallelism-in-ispc">Task Parallelism in ISPC</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-ispc-standard-library">The ISPC Standard Library</a><ul>
<li><a class="reference internal" href="#math-functions">Math Functions</a></li>
<li><a class="reference internal" href="#output-functions">Output Functions</a></li>
<li><a class="reference internal" href="#cross-lane-operations">Cross-Lane Operations</a></li>
<li><a class="reference internal" href="#low-level-bits">Low-Level Bits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interoperability-with-the-application">Interoperability with the Application</a><ul>
<li><a class="reference internal" href="#interoperability-overview">Interoperability Overview</a></li>
<li><a class="reference internal" href="#data-layout">Data Layout</a></li>
<li><a class="reference internal" href="#data-alignment-and-aliasing">Data Alignment and Aliasing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-ispc-effectively">Using ISPC Effectively</a><ul>
<li><a class="reference internal" href="#restructuring-existing-programs-to-use-ispc">Restructuring Existing Programs to Use ISPC</a></li>
<li><a class="reference internal" href="#understanding-how-to-interoperate-with-the-application-s-data">Understanding How to Interoperate With the Application's Data</a></li>
<li><a class="reference internal" href="#communicating-between-spmd-program-instances">Communicating Between SPMD Program Instances</a></li>
<li><a class="reference internal" href="#gather-and-scatter">Gather and Scatter</a></li>
<li><a class="reference internal" href="#low-level-vector-tricks">Low-level Vector Tricks</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a></li>
<li><a class="reference internal" href="#the-fast-math-option">The &quot;Fast math&quot; Option</a></li>
<li><a class="reference internal" href="#inline-aggressively">&quot;Inline&quot; Aggressively</a></li>
<li><a class="reference internal" href="#small-performance-tricks">Small Performance Tricks</a></li>
<li><a class="reference internal" href="#instrumenting-your-ispc-programs">Instrumenting Your ISPC Programs</a></li>
</ul>
</li>
<li><a class="reference internal" href="#disclaimer-and-legal-information">Disclaimer and Legal Information</a></li>
<li><a class="reference internal" href="#optimization-notice">Optimization Notice</a></li>
</ul>
<div class="section" id="recent-changes-to-ispc">
<h1>Recent Changes to ISPC</h1>
<p>This section summarizes recent changes and bugfixes.</p>
<ul class="simple">
<li>17 May: Fixed a number of bugs related to error handling in Windows*.  In
particular, if you use the <tt class="docutils literal">/E</tt> command line flag to <tt class="docutils literal">cl.exe</tt> (rather
than <tt class="docutils literal">/EP</tt>) when using it as a preprocessor, then <tt class="docutils literal">ispc</tt> will
correctly report the source file position with warnings and errors.</li>
<li>15 May: Improved error messages and warnings in many cases.  For example,
the column number is reported along with the line number and
the source line with the error is printed as part of the message.</li>
<li>8 May: <tt class="docutils literal">ispc</tt>'s typechecker has been substantially improved in how it
handles <tt class="docutils literal">const</tt>-qualified types.  Some programs that previously
compiled may now fail with errors related to <tt class="docutils literal">const</tt>.  For example,
<tt class="docutils literal">ispc</tt> issues an error message if you try to assign a member of a const
structure.</li>
<li>2 May: &quot;uniform&quot; short-vector types are now stored across the lanes of
the SIMD registers.  This enables you to also write classic 'explicit
vector' computation in <tt class="docutils literal">ispc</tt> as well.  This change does change how
these types are laid out in memory; see <a class="reference internal" href="#data-layout">Data Layout</a> for more details.)</li>
</ul>
</div>
<div class="section" id="getting-started-with-ispc">
<h1>Getting Started with ISPC</h1>
<div class="section" id="installing-ispc">
<h2>Installing ISPC</h2>
<p>The <a class="reference external" href="downloads.html">ispc downloads web page</a> has prebuilt executables for Windows*,
Linux* and Mac OS* available for download.  Alternatively, you can
download the source code from that page and build it yourself; see see the
<a class="reference external" href="http://github.com/ispc/ispc/wiki">ispc wiki</a> for instructions about building <tt class="docutils literal">ispc</tt> from source.</p>
<p>Once you have an executable for your system, copy it into a directory
that's in your <tt class="docutils literal">PATH</tt>.  Congratulations--you've now installed <tt class="docutils literal">ispc</tt>.</p>
</div>
<div class="section" id="compiling-and-running-a-simple-ispc-program">
<h2>Compiling and Running a Simple ISPC Program</h2>
<p>The directory <tt class="docutils literal">examples/simple</tt> in the <tt class="docutils literal">ispc</tt> distribution includes a
simple example of how to use <tt class="docutils literal">ispc</tt> with a short C++ program.  See the
file <tt class="docutils literal">simple.ispc</tt> in that directory (also reproduced here.)</p>
<pre class="literal-block">
export void simple(uniform float vin[], uniform float vout[],
                   uniform int count) {
    for (uniform int i = 0; i &lt; count; i += programCount) {
        int index = i + programIndex;
        float v = vin[index];
        if (v &lt; 3.)
            v = v * v;
        else
            v = sqrt(v);
        vout[index] = v;
    }
}
</pre>
<p>This program loops over an array of values in <tt class="docutils literal">vin</tt> and computes an
output value for each one.  For each value in <tt class="docutils literal">vin</tt>, if its value is less
than three, the output is the value squared, otherwise it's the square root
of the value.</p>
<p>The first thing to notice in this program is the presence of the <tt class="docutils literal">export</tt>
keyword in the function definition; this indicates that the function should
be made available to be called from application code.  The <tt class="docutils literal">uniform</tt>
qualifiers on the parameters to <tt class="docutils literal">simple</tt> as well as for the variable
<tt class="docutils literal">i</tt> indicate that the correpsonding variables are non-vector
quantities--they are discussed in detail in the <a class="reference internal" href="#uniform-and-varying-qualifiers">Uniform and Varying
Qualifiers</a> section.</p>
<p>Each iteration of the for loop works on a number of input values in
parallel.  The built-in <tt class="docutils literal">programCount</tt> variable indicates how many
program instances are running in parallel; it is equal to the SIMD width of
the machine.  (For example, the value is four on Intel® SSE, eight on
Intel® AVX, etc.)  Thus, we can see that each execution of the loop will
work on that many output values in parallel.  There is an implicit
assumption that <tt class="docutils literal">programCount</tt> divides the <tt class="docutils literal">count</tt> parameter without
remainder; the more general case case can be handled with a small amount of
additional code.</p>
<p>To load the <tt class="docutils literal">programCount</tt>-worth of values, the program computes an index
using the sum of <tt class="docutils literal">i</tt>, which gives the first value to work on in this
iteration, and <tt class="docutils literal">programIndex</tt>, which gives a unique integer identifier
for each running program instance, counting from zero.  Thus, the load from
<tt class="docutils literal">vin</tt> loads the values at offset <tt class="docutils literal">i+0</tt>, <tt class="docutils literal">i+1</tt>, <tt class="docutils literal">i+2</tt>, ..., from the
<tt class="docutils literal">vin</tt> array into the vector variable <tt class="docutils literal">v</tt>.  This general idiom should be
familiar to CUDA* or OpenCL* programmers, where thread ids serve a
similar role to <tt class="docutils literal">programIndex</tt> in <tt class="docutils literal">ispc</tt>.  See the section <a class="reference internal" href="#mapping-data-to-program-instances">Mapping
Data to Program Instances</a> for more detail.</p>
<p>The program can then proceed, doing computation and control flow based on
the values loaded.  The result from the running program instances is
written to the <tt class="docutils literal">vout</tt> array before the next loop iteration runs.</p>
<p>For a simple program like this one, the performance difference versus a
regular scalar C/C++ implementation are minimal.  For more
complex programs that do more substantial amounts of computation, doing
that computation in parallel across the machine's SIMD lanes can have a
substantial performance benefit.</p>
<p>On Linux* and Mac OS*, the makefile in that directory compiles this program.
For Windows*, open the <tt class="docutils literal">examples/examples.sln</tt> file in Microsoft Visual
C++ 2010* to build this (and the other) examples.  In either case,
build it now!  We'll walk through the details of the compilation steps in
the following section, <a class="reference internal" href="#using-the-ispc-compiler">Using The ISPC Compiler</a>.)  In addition to
compiling the <tt class="docutils literal">ispc</tt> program, in this case the <tt class="docutils literal">ispc</tt> compiler also
generates a small header file, <tt class="docutils literal">simple.h</tt>.  This header file includes the
declaration for the C-callable function that the above <tt class="docutils literal">ispc</tt> program is
compiled to.  The relevant parts of this file are:</p>
<pre class="literal-block">
#ifdef __cplusplus
extern &quot;C&quot; {
#endif // __cplusplus
    extern void simple(float vin[], float vout[], int32_t count);
#ifdef __cplusplus
}
#endif // __cplusplus
</pre>
<p>It's not mandatory to <tt class="docutils literal">#include</tt> the generated header file in your C/C++
code (you can alternatively use a manually-written <tt class="docutils literal">extern</tt> declaration
of the <tt class="docutils literal">ispc</tt> functions you use), but it's a helpful check to ensure that
the function signatures are as expected on both sides.</p>
<p>Here is the main program, <tt class="docutils literal">simple.cpp</tt>, which calls the <tt class="docutils literal">ispc</tt> function
above.</p>
<pre class="literal-block">
#include &lt;stdio.h&gt;
#include &quot;simple.h&quot;

int main() {
    float vin[16], vout[16];
    for (int i = 0; i &lt; 16; ++i)
        vin[i] = i;

    simple(vin, vout, 16);

    for (int i = 0; i &lt; 16; ++i)
        printf(&quot;%d: simple(%f) = %f\n&quot;, i, vin[i], vout[i]);
}
</pre>
<p>Note that the call to the <tt class="docutils literal">ispc</tt> function in the middle of <tt class="docutils literal">main()</tt> is
a regular function call.  (And it has the same overhead as a C/C++ function
call, for that matter.)</p>
<p>When the executable <tt class="docutils literal">simple</tt> runs, it generates the expected output:</p>
<pre class="literal-block">
0: simple(0.000000) = 0.000000
1: simple(1.000000) = 1.000000
2: simple(2.000000) = 4.000000
3: simple(3.000000) = 1.732051
...
</pre>
<p>There is also a small example of using <tt class="docutils literal">ispc</tt> to compute the Mandelbrot
set; see the <a class="reference external" href="http://ispc.github.com/example.html">Mandelbrot set example</a> page on the <tt class="docutils literal">ispc</tt> website for a
walkthrough of it.</p>
</div>
</div>
<div class="section" id="using-the-ispc-compiler">
<h1>Using The ISPC Compiler</h1>
<p>To go from a <tt class="docutils literal">ispc</tt> source file to an object file that can be linked
with application code, enter the following command</p>
<pre class="literal-block">
ispc foo.ispc -o foo.o
</pre>
<p>On Linux* and Mac OS*, <tt class="docutils literal">ispc</tt> automatically runs the C preprocessor on
your input program; under Windows*, this must be done manually.  With
Microsoft Visual C++ 2010*, the following custom build step for
<tt class="docutils literal">ispc</tt> source files takes care of this job:</p>
<pre class="literal-block">
cl /E /TP %(Filename).ispc | ispc - -o %(Filename).obj -h %(Filename).h
</pre>
<p>The <tt class="docutils literal">cl</tt> call runs the C preprocessor on the <tt class="docutils literal">ispc</tt> file; the result is
piped to <tt class="docutils literal">ispc</tt> to generate an object file and a header.  As an example,
see the file <tt class="docutils literal">simple.vcxproj</tt> in the <tt class="docutils literal">examples/simple</tt> directory of the
<tt class="docutils literal">ispc</tt> distribution.</p>
<div class="section" id="command-line-options">
<h2>Command-line Options</h2>
<p>The <tt class="docutils literal">ispc</tt> executable can be run with <tt class="docutils literal"><span class="pre">--help</span></tt> to print a list of
accepted command-line arguments.  By default, the compiler compiles the
provided program (and issues warnings and errors), but doesn't
generate any output.</p>
<p>If the <tt class="docutils literal"><span class="pre">-o</span></tt> flag is given, it will generate an output file (a native
object file by default).  To generate a text assembly file, pass
<tt class="docutils literal"><span class="pre">--emit-asm</span></tt>:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.s --emit-asm
</pre>
<p>To generate LLVM bitcode, use the <tt class="docutils literal"><span class="pre">--emit-llvm</span></tt> flag.</p>
<p>By default, an optimized x86-64 object file tuned for Intel® Core
processors CPUs is built.  You can use the <tt class="docutils literal"><span class="pre">--arch</span></tt> command line flag to
specify a 32-bit x86 target:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.obj --arch=x86
</pre>
<p>Optimizations can be turned off with <tt class="docutils literal"><span class="pre">-O0</span></tt>:</p>
<pre class="literal-block">
ispc foo.ispc -o foo.obj -O0
</pre>
<p>On Mac* and Linux*, there is early support for generating debugging
symbols; this is enabled with the <tt class="docutils literal"><span class="pre">-g</span></tt> command-line flag.</p>
<p>The <tt class="docutils literal"><span class="pre">-h</span></tt> flag can also be used to direct <tt class="docutils literal">ispc</tt> to generate a C/C++
header file that includes C/C++ declarations of the C-callable <tt class="docutils literal">ispc</tt>
functions and the types passed to it.</p>
<p>On Linux* and Mac OS*, <tt class="docutils literal"><span class="pre">-D</span></tt> can be used to specify definitions to be
passed along to the C pre-prcessor, which runs over the program input
before it's compiled.  On Windows®, pre-processor definitions should be
provided to the <tt class="docutils literal">cl</tt> call.</p>
<p>By default, the compiler generates x86-64 Intel® SSE4 code.  To generate
32-bit code, you can use the the <tt class="docutils literal"><span class="pre">--arch=x86</span></tt> command-line flag.  To
select Intel® SSE2, use <tt class="docutils literal"><span class="pre">--target=sse2</span></tt>.</p>
<p><tt class="docutils literal">ispc</tt> supports an alternative method for generating Intel® SSE4 code,
where the program is &quot;doubled up&quot; and eight instances of it run in
parallel, rather than just four.  For workloads that don't require large
numbers of registers, this method can lead to significantly more efficient
execution thanks to greater instruction level parallelism.  This option is
selected with <tt class="docutils literal"><span class="pre">--target=sse4x2</span></tt>.</p>
<p>The compiler issues a number of performance warnings for code constructs
that compile to relatively inefficient code.  These warnings can be
silenced with the <tt class="docutils literal"><span class="pre">--wno-perf</span></tt> flag (or by using <tt class="docutils literal"><span class="pre">--woff</span></tt>, which turns
off all warnings.)</p>
</div>
</div>
<div class="section" id="the-ispc-language">
<h1>The ISPC Language</h1>
<p><tt class="docutils literal">ispc</tt>'s syntax is based on C and is designed to be as similar to C
as much as possible.  Between syntactic differences and the fundamentally
parallel execution model (versus C's serial model), C code is not directly
portable to <tt class="docutils literal">ispc</tt>, although starting with working C code and porting it
to <tt class="docutils literal">ispc</tt> can be an efficient way to write <tt class="docutils literal">ispc</tt> programs.</p>
<div class="section" id="lexical-structure">
<h2>Lexical Structure</h2>
<p>Tokens in <tt class="docutils literal">ispc</tt> are delimted by white-space and comments.  The
white-space characters are the usual set of spaces, tabs, and carriage
returns/line feeds.  Comments can be delinated with <tt class="docutils literal">//</tt>, which starts a
comment that continues to the end of the line, or the start of a comment
can be delinated with <tt class="docutils literal">/*</tt> and the end with <tt class="docutils literal">*/</tt>.  Like in C/C++,
comments can't be nested.</p>
<p>Identifiers in <tt class="docutils literal">ispc</tt> are sequences of characters that start with an
underscore or an upper-case or lower-case letter, and then followed by
zero or more letters, numbers, or underscores.</p>
<p>Integer numeric constants can be specified in base 10 or in hexidecimal.
Base 10 constants are given by a sequence of one or more digits from 0 to
9.  Hexidecimal constants are denoted by a leading <tt class="docutils literal">0x</tt> and then one or
more digits from 0-9, a-f, or A-F.</p>
<p>Floating-point constants can be specified in one of three ways.  First,
they may be a sequence of zero or more digits from 0 to 9, followed by a
period, followed by zero or more digits from 0 to 9. (There must be at
least one digit before or after the period).</p>
<p>The second option is scientific notation, where a base value is specified
as the first form of a floating-point constant but is then followed by an
&quot;e&quot; or &quot;E&quot;, then a plus sign or a minus sign, and then an exponent.</p>
<p>Finally, floating-point constants may be specified as hexidecimal
constants; this form can ensure a perfectly bit-accurate representation of
a particular floating-point number.  These are specified with an &quot;0x&quot;
prefix, followed by a zero or a one, a period, and then the remainder of
the mantissa in hexidecimal form, with digits from 0-9, a-f, or A-F.  The
start of the exponent is denoted by a &quot;p&quot;, which is then followed by an
optional plus or minus sign and then digits from 0 to 9.  For example:</p>
<pre class="literal-block">
float two = 0x1p+1;  // 2.0
float pi  = 0x1.921fb54442d18p+1;  // 3.1415926535...
float neg = -0x1.ffep+11;  // -4095.
</pre>
<p>Floating-point constants can optionally have a &quot;f&quot; or &quot;F&quot; suffix (<tt class="docutils literal">ispc</tt>
currently treats all floating-point constants as having 32-bit precision,
making this suffix unnecessary.)</p>
<p>String constants in <tt class="docutils literal">ispc</tt> are denoted by an opening double quote <tt class="docutils literal">&quot;</tt>
followed by any character other than a newline, up to a closing double
quote.  Within the string, a number of special escape sequences can be used
to specify special characters.  These sequences all start with an initial
<tt class="docutils literal">\</tt> and are listed below:</p>
<table border="1" class="docutils">
<caption>Escape sequences in strings</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">\\</tt></td>
<td>backslash: <tt class="docutils literal">\</tt></td>
</tr>
<tr><td><tt class="docutils literal">\&quot;</tt></td>
<td>double quotation mark: <tt class="docutils literal">&quot;</tt></td>
</tr>
<tr><td><tt class="docutils literal">\'</tt></td>
<td>single quotation mark: <tt class="docutils literal">'</tt></td>
</tr>
<tr><td><tt class="docutils literal">\a</tt></td>
<td>bell (alert)</td>
</tr>
<tr><td><tt class="docutils literal">\b</tt></td>
<td>backspace character</td>
</tr>
<tr><td><tt class="docutils literal">\f</tt></td>
<td>formfeed character</td>
</tr>
<tr><td><tt class="docutils literal">\n</tt></td>
<td>newline</td>
</tr>
<tr><td><tt class="docutils literal">\r</tt></td>
<td>carriabe return</td>
</tr>
<tr><td><tt class="docutils literal">\t</tt></td>
<td>horizontal tab</td>
</tr>
<tr><td><tt class="docutils literal">\v</tt></td>
<td>vertical tab</td>
</tr>
<tr><td><tt class="docutils literal">\</tt> followed by one or more digits from 0-8</td>
<td>ASCII character in octal notation</td>
</tr>
<tr><td><tt class="docutils literal">\x</tt>, followed by one or more digits from 0-9, a-f, A-F</td>
<td>ASCII character in hexidecimal notation</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">ispc</tt> doesn't support a string data type; string constants can be passed
as the first argument to the <tt class="docutils literal">print()</tt> statement, however.  <tt class="docutils literal">ispc</tt> also
doesn't support character constants.</p>
<p>The following identifiers are reserved as language keywords: <tt class="docutils literal">bool</tt>,
<tt class="docutils literal">break</tt>, <tt class="docutils literal">case</tt>, <tt class="docutils literal">cbreak</tt>, <tt class="docutils literal">ccontinue</tt>, <tt class="docutils literal">cdo</tt>, <tt class="docutils literal">cfor</tt>,
<tt class="docutils literal">char</tt>, <tt class="docutils literal">cif</tt>, <tt class="docutils literal">cwhile</tt>, <tt class="docutils literal">const</tt>, <tt class="docutils literal">continue</tt>, <tt class="docutils literal">creturn</tt>,
<tt class="docutils literal">default</tt>, <tt class="docutils literal">do</tt>, <tt class="docutils literal">double</tt>, <tt class="docutils literal">else</tt>, <tt class="docutils literal">enum</tt>, <tt class="docutils literal">export</tt>,
<tt class="docutils literal">extern</tt>, <tt class="docutils literal">false</tt>, <tt class="docutils literal">float</tt>, <tt class="docutils literal">for</tt>, <tt class="docutils literal">goto</tt>, <tt class="docutils literal">if</tt>, <tt class="docutils literal">inline</tt>, <tt class="docutils literal">int</tt>,
<tt class="docutils literal">int32</tt>, <tt class="docutils literal">int64</tt>, <tt class="docutils literal">launch</tt>, <tt class="docutils literal">print</tt>, <tt class="docutils literal">reference</tt>, <tt class="docutils literal">return</tt>,
<tt class="docutils literal">signed</tt>, <tt class="docutils literal">sizeof</tt>, <tt class="docutils literal">soa</tt>, <tt class="docutils literal">static</tt>, <tt class="docutils literal">struct</tt>, <tt class="docutils literal">switch</tt>,
<tt class="docutils literal">sync</tt>, <tt class="docutils literal">task</tt>, <tt class="docutils literal">true</tt>, <tt class="docutils literal">typedef</tt>, <tt class="docutils literal">uniform</tt>, <tt class="docutils literal">union</tt>,
<tt class="docutils literal">unsigned</tt>, <tt class="docutils literal">varying</tt>, <tt class="docutils literal">void</tt>, <tt class="docutils literal">volatile</tt>, <tt class="docutils literal">while</tt>.</p>
<p><tt class="docutils literal">ispc</tt> defines the following operators and punctuation:</p>
<table border="1" class="docutils">
<caption>Operators</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td>Symbols</td>
<td>Use</td>
</tr>
<tr><td><tt class="docutils literal">=</tt></td>
<td>Assignment</td>
</tr>
<tr><td><tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, *, <tt class="docutils literal">/</tt>, <tt class="docutils literal">%</tt></td>
<td>Arithmetic operators</td>
</tr>
<tr><td><tt class="docutils literal">&amp;</tt>, <tt class="docutils literal">|</tt>, <tt class="docutils literal">^</tt>, <tt class="docutils literal">!</tt>, <tt class="docutils literal">~</tt>, <tt class="docutils literal">&amp;&amp;</tt>, <tt class="docutils literal">||</tt>, <tt class="docutils literal">&lt;&lt;</tt>, <tt class="docutils literal">&gt;&gt;</tt></td>
<td>Logical and bitwise operators</td>
</tr>
<tr><td><tt class="docutils literal">++</tt>, <tt class="docutils literal"><span class="pre">--</span></tt></td>
<td>Pre/post increment/decrement</td>
</tr>
<tr><td><tt class="docutils literal">&lt;</tt>, <tt class="docutils literal">&lt;=</tt>, <tt class="docutils literal">&gt;</tt>, <tt class="docutils literal">&gt;=</tt>, <tt class="docutils literal">==</tt>, <tt class="docutils literal">!=</tt></td>
<td>Relational operators</td>
</tr>
<tr><td><tt class="docutils literal">*=</tt>, <tt class="docutils literal">/=</tt>, <tt class="docutils literal">+=</tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>, <tt class="docutils literal">&lt;&lt;=</tt>, <tt class="docutils literal">&gt;&gt;=</tt>, <tt class="docutils literal">&amp;=</tt>, <tt class="docutils literal">|=</tt></td>
<td>Compound assignment operators</td>
</tr>
<tr><td><tt class="docutils literal">?</tt>, <tt class="docutils literal">:</tt></td>
<td>Selection operators</td>
</tr>
<tr><td><tt class="docutils literal">;</tt></td>
<td>Statement separator</td>
</tr>
<tr><td><tt class="docutils literal">,</tt></td>
<td>Expression separator</td>
</tr>
<tr><td><tt class="docutils literal">.</tt></td>
<td>Member access</td>
</tr>
</tbody>
</table>
<p>A number of tokens are used for grouping in <tt class="docutils literal">ispc</tt>:</p>
<table border="1" class="docutils">
<caption>Grouping Tokens</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><tt class="docutils literal">(</tt>, <tt class="docutils literal">)</tt></td>
<td>Parenthesization of expressions, function calls, delimiting specifiers
for control flow constructs.</td>
</tr>
<tr><td><tt class="docutils literal">[</tt>, <tt class="docutils literal">]</tt></td>
<td>Array and short-vector indexing</td>
</tr>
<tr><td><tt class="docutils literal">{</tt>, <tt class="docutils literal">}</tt></td>
<td>Compound statements</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="basic-types-and-type-qualifiers">
<h2>Basic Types and Type Qualifiers</h2>
<p><tt class="docutils literal">ispc</tt> is a statically-typed language.  It supports a variety of basic
types.</p>
<ul class="simple">
<li><tt class="docutils literal">void</tt>: &quot;empty&quot; type representing no value.</li>
<li><tt class="docutils literal">bool</tt>: boolean value; may be assigned <tt class="docutils literal">true</tt>, <tt class="docutils literal">false</tt>, or the
value of a boolean expression.</li>
<li><tt class="docutils literal">int</tt>: 32-bit signed integer; may also be specified as <tt class="docutils literal">int32</tt>.</li>
<li><tt class="docutils literal">unsigned int</tt>: 32-bit unsigned integer; may also be specified as
<tt class="docutils literal">unsigned int32</tt>.</li>
<li><tt class="docutils literal">float</tt>: 32-bit floating point value</li>
<li><tt class="docutils literal">int64</tt>: 64-bit signed integer.</li>
<li><tt class="docutils literal">unsigned int64</tt>: 64-bit unsigned integer.</li>
<li><tt class="docutils literal">double</tt>: 64-bit double-precision floating point value.</li>
</ul>
<p>Implicit type conversion between values of different types is done
automatically by the <tt class="docutils literal">ispc</tt> compiler.  Thus, a value of <tt class="docutils literal">float</tt> type
can be assigned to a variable of <tt class="docutils literal">int</tt> type directly.  In binary
arithmetic expressions with mixed types, types are promoted to the &quot;more
general&quot; of the two types, with the following precedence:</p>
<pre class="literal-block">
double &gt; uint64 &gt; int64 &gt; float &gt; uint32 &gt; int32 &gt; bool
</pre>
<p>In other words, adding an <tt class="docutils literal">int64</tt> to a <tt class="docutils literal">double</tt> causes the <tt class="docutils literal">int64</tt> to
be converted to a <tt class="docutils literal">double</tt>, the addition to be performed, and a
<tt class="docutils literal">double</tt> value to be returned.  If a different conversion behavior is
desired, then explicit type-casts can be used, where the destination type
is provided in parenthesis around the expression:</p>
<pre class="literal-block">
double foo = 1. / 3.;
int bar = (float)bar + (float)bar;  // 32-bit float addition
</pre>
<p>Note: if a <tt class="docutils literal">bool</tt> is converted to an integer numeric type (<tt class="docutils literal">int</tt>,
<tt class="docutils literal">int64</tt>, etc.), then the conversion is done with sign extension, not zero
extension.  Thus, the resulting value has all bits set if the <tt class="docutils literal">bool</tt> is
<tt class="docutils literal">true</tt>; for example, <tt class="docutils literal">0xffffffff</tt> for <tt class="docutils literal">int32</tt>.  This differs from C
and C++, where a <tt class="docutils literal">true</tt> bool is converted to the integer value one.</p>
<p>Variables can be declared with the <tt class="docutils literal">const</tt> qualifier, which prohibits
their modification.</p>
<pre class="literal-block">
const float PI = 3.1415926535;
</pre>
<p>As in C, the <tt class="docutils literal">extern</tt> qualifier can be used to declare a function or
global variable defined in another source file, and the <tt class="docutils literal">static</tt>
qualifier can be used to define a variable or function that is only visible
in the current scope.  The values of <tt class="docutils literal">static</tt> variables declared in
functions are preserved across function calls.</p>
<p>The <tt class="docutils literal">typedef</tt> keyword can be used to name types:</p>
<pre class="literal-block">
typedef Float3 float[3];
</pre>
<p><tt class="docutils literal">typedef</tt> doesn't create a new type: it just provides an alternative name
for an existing type.  Thus, in the above example, it is legal to pass a
value with <tt class="docutils literal">float[3]</tt> type to a function that has been declared to take a
<tt class="docutils literal">Float3</tt> parameter.</p>
<p><tt class="docutils literal">ispc</tt> provides a <tt class="docutils literal">reference</tt> qualifier that can be used for passing
values to functions by reference so that functions can return multiple
results or modify existing variables.</p>
<pre class="literal-block">
void increment(reference float f) {
    ++f;
}
</pre>
<p><tt class="docutils literal">ispc</tt> doesn't currently support pointer types.</p>
</div>
<div class="section" id="short-vector-types">
<h2>Short Vector Types</h2>
<p><tt class="docutils literal">ispc</tt> supports a parameterized type to define short vectors.  These
short vectors can only be used with basic types like <tt class="docutils literal">float</tt> and <tt class="docutils literal">int</tt>;
they can't be applied to arrays or structures.  Note: <tt class="docutils literal">ispc</tt> does <em>not</em>
use these short vectors to facilitate program vectorization; they are
purely a syntactic convenience.  Using them or writing the corresponding
code without them shouldn't lead to any noticeable performance differences
between the two approaches.</p>
<p>Syntax similar to C++ templates is used to declare these types:</p>
<pre class="literal-block">
float&lt;3&gt; foo;   // vector of three floats
double&lt;6&gt; bar;
</pre>
<p>The length of these vectors can be arbitrarily long, though the expected
usage model is relatively short vectors.</p>
<p>You can use <tt class="docutils literal">typedef</tt> to create types that don't carry around
the brackets around the vector length:</p>
<pre class="literal-block">
typedef float&lt;3&gt; float3;
</pre>
<p><tt class="docutils literal">ispc</tt> doesn't support templates in general.  In particular,
not only must the vector length be a compile-time constant, but it's
also not possible to write functions that are parameterized by vector
length.</p>
<pre class="literal-block">
uniform int i = foo();
// ERROR: length must be compile-time constant
float&lt;i&gt; vec;
// ERROR: can't write functions parameterized by vector length
float&lt;N&gt; func(float&lt;N&gt; val);
</pre>
<p>Arithmetic on these short vector types works as one would expect; the
operation is applied component-wise to the values in the vector.  Here is a
short example:</p>
<pre class="literal-block">
float&lt;3&gt; func(float&lt;3&gt; a, float&lt;3&gt; b) {
    a += b;    // add individual elements of a and b
    a *= 2.;   // multiply all elements of a by 2
    bool&lt;3&gt; test = a &lt; b;  // component-wise comparison
    return test ? a : b;   // return each minimum component
}
</pre>
<p>As shown by the above code, scalar types automatically convert to
corresponding vector types when used in vector expressions.  In this
example, the constant <tt class="docutils literal">2.</tt> above is converted to a three-vector of 2s for
the multiply in the second line of the function implementation.</p>
<p>Type conversion between other short vector types also works as one would
expect, though the two vector types must have the same length:</p>
<pre class="literal-block">
float&lt;3&gt; foo = ...;
int&lt;3&gt; bar = foo;    // ok, cast elements to ints
int&lt;4&gt; bat = foo;    // ERROR: different vector lengths
float&lt;4&gt; bing = foo; // ERROR: different vector lengths
</pre>
<p>There are two mechanisms to access the individual elements of these short
vector data types.  The first is with the array indexing operator:</p>
<pre class="literal-block">
float&lt;4&gt; foo;
for (uniform int i = 0; i &lt; 4; ++i)
    foo[i] = i;
</pre>
<p><tt class="docutils literal">ispc</tt> also provides a specialized mechanism for naming and accessing
the first few elements of short vectors based on an overloading of
the structure member access operator.  The syntax is similar to that used
in HLSL, for example.</p>
<pre class="literal-block">
float&lt;3&gt; position;
position.x = ...;
position.y = ...;
position.z = ...;
</pre>
<p>More specifically, the first element of any short vector type can be
accessed with <tt class="docutils literal">.x</tt> or <tt class="docutils literal">.r</tt>, the second with <tt class="docutils literal">.y</tt> or <tt class="docutils literal">.g</tt>, the third
with <tt class="docutils literal">.z</tt> or <tt class="docutils literal">.b</tt>, and the fourth with <tt class="docutils literal">.w</tt> or <tt class="docutils literal">.a</tt>.  Just like
using the array indexing operator with an index that is greater than the
vector size, accessing an element that is beyond the vector's size is
undefined behavior and may cause your program to crash.</p>
<p>Note: <tt class="docutils literal">ispc</tt> doesn't support the &quot;swizzling&quot; operations that languages
like HLSL do.  Only a single element of the vector can be accessed at a
time with these member operators.</p>
<pre class="literal-block">
float&lt;3&gt; foo = ...;
float&lt;2&gt; bar = foo.xy;  // ERROR
foo.xz = ...;           // ERROR
func(foo.xyx);          // ERROR
</pre>
<p>For convenience, short vectors can be initialized with a list of individual
element values:</p>
<pre class="literal-block">
float x = ..., y = ..., z = ...;
float&lt;3&gt; pos = { x, y, z };
</pre>
</div>
<div class="section" id="struct-and-array-types">
<h2>Struct and Array Types</h2>
<p>More complex data structures can be built using <tt class="docutils literal">struct</tt> and arrays.</p>
<pre class="literal-block">
struct Foo {
    float time;
    int flags[10];
};
</pre>
<p>The size of arrays must be a compile-time constant, though functions can be
declared to take &quot;unsized arrays&quot; as parameters so that arrays of any size
may be passed:</p>
<pre class="literal-block">
void foo(float array[], int length);
</pre>
<p>As in C++, after a <tt class="docutils literal">struct</tt> is declared, an instance can be created using
the <tt class="docutils literal">struct</tt>'s name:</p>
<pre class="literal-block">
Foo f;
</pre>
<p>Alternatively, <tt class="docutils literal">struct</tt> can be used before the structure name:</p>
<pre class="literal-block">
struct Foo f;
</pre>
</div>
<div class="section" id="declarations-and-initializers">
<h2>Declarations and Initializers</h2>
<p>Variables are declared and assigned just as in C:</p>
<pre class="literal-block">
float foo = 0, bar[5];
float bat = func(foo);
</pre>
<p>If a variable is declared without an initializer expression, then its value
is undefined until a value is assigned to it.  Reading an undefined
variable may lead to unexpected program behavior.</p>
<p>Any variable that is declared at file scope (i.e. outside a function) is a
global variable.  If a global variable is qualified with the <tt class="docutils literal">static</tt>
keyword, then its only visible within the compilation unit in which it was
defined.  As in C/C++, a variable with a <tt class="docutils literal">static</tt> qualifier inside a
functions maintains its value across function invocations.</p>
<p>Like C++, variables don't need to be declared at the start of a basic
block:</p>
<pre class="literal-block">
int foo = ...;
if (foo &lt; 2) { ... }
int bar = ...;
</pre>
<p>Variables can also be declared in <tt class="docutils literal">for</tt> statement initializers:</p>
<pre class="literal-block">
for (int i = 0; ...)
</pre>
<p>Arrays can be initialized with either a scalar value or with individual
element values in braces:</p>
<pre class="literal-block">
int foo[10] = x;  // all ten elements take the value of x
int bar[2][4] = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } };
</pre>
<p>Structures can also be initialized both with scalar values or with element
values in braces:</p>
<pre class="literal-block">
struct Color { float r, g, b; };
....
Color c = 1; // all are one
Color d = { 0.5, .75, 1.0 }; // r = 0.5, ...
</pre>
</div>
<div class="section" id="function-declarations">
<h2>Function Declarations</h2>
<p>Functions can be declared with a number of qualifiers that affect their
visibility and capabilities.  As in C/C++, functions have global visibility
by default.  If a function is declared with a <tt class="docutils literal">static</tt> qualifier, then it
is only visible in the file in which it was declared.</p>
<p>Any function that can be launched with the <tt class="docutils literal">launch</tt> construct in <tt class="docutils literal">ispc</tt>
must have a <tt class="docutils literal">task</tt> qualifier; see <a class="reference internal" href="#task-parallelism-in-ispc">Task Parallelism in ISPC</a> for more
discussion of launching tasks in <tt class="docutils literal">ispc</tt>.</p>
<p>Functions that are intended to be called from C/C++ application code must
have the <tt class="docutils literal">export</tt> qualifier.  This causes them to have regular C linkage
and to have their declarations included in header files, if the <tt class="docutils literal">ispc</tt>
compiler is directed to generated a C/C++ header file for the file it
compiled.</p>
<p>Finally, any function defined with an <tt class="docutils literal">inline</tt> qualifier will always be
inlined by <tt class="docutils literal">ispc</tt>; <tt class="docutils literal">inline</tt> is not a hint, but forces inlining.  The
compiler will opportunistically inline short functions depending on their
complexity, but any function that should always be inlined should have the
<tt class="docutils literal">inline</tt> qualifier.</p>
</div>
<div class="section" id="expressions">
<h2>Expressions</h2>
<p>All of the operators from C that you'd expect for writing expressions are
present.  Rather than enumerating all of them, here is a short summary of
the range of them available in action.</p>
<pre class="literal-block">
unsigned int i = 0x1234feed;
unsigned int j = (i &lt;&lt; 3) ^ ~(i - 3);
i += j / 6;
float f = 1.234e+23;
float g = j * f / (2.f * i);
double h = (g &lt; 2) ? f : g/5;
</pre>
<p>Structure member access and array indexing also work as in C.</p>
<pre class="literal-block">
struct Foo { float f[5]; int i; };
Foo foo = { { 1,2,3,4,5 }, 2 };
return foo.f[4] - foo.i;
</pre>
</div>
<div class="section" id="control-flow">
<h2>Control Flow</h2>
<p><tt class="docutils literal">ispc</tt> supports most of C's control flow constructs, including <tt class="docutils literal">if</tt>,
<tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, <tt class="docutils literal">do</tt>.  You can use <tt class="docutils literal">break</tt> and <tt class="docutils literal">continue</tt>
statements in <tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, and <tt class="docutils literal">do</tt> loops.</p>
<p>There are variants of the <tt class="docutils literal">if</tt>, <tt class="docutils literal">do</tt>, <tt class="docutils literal">while</tt>, <tt class="docutils literal">for</tt>, <tt class="docutils literal">break</tt>,
<tt class="docutils literal">continue</tt>, and <tt class="docutils literal">return</tt> statements (<tt class="docutils literal">cif</tt>, <tt class="docutils literal">cdo</tt>, <tt class="docutils literal">cwhile</tt>,
<tt class="docutils literal">cfor</tt>, <tt class="docutils literal">cbreak</tt>, <tt class="docutils literal">ccontinue</tt>, and <tt class="docutils literal">creturn</tt>, respectively) that
provide the compiler a hint that the control flow is expected to be
coherent at that particular point, thus allowing the compiler to do
additional optimizations for that case.  These are described in the
<a class="reference internal" href="#coherent-control-flow-statements">&quot;Coherent&quot; Control Flow Statements</a> section.</p>
<p><tt class="docutils literal">ispc</tt> does not support <tt class="docutils literal">switch</tt> statements or <tt class="docutils literal">goto</tt>.</p>
</div>
<div class="section" id="functions">
<h2>Functions</h2>
<p>Like C, functions must be declared before they are called, though a forward
declaration can be used before the actual function definition.  Functions
can be overloaded by parameter type.  Given multiple definitions of a
function, <tt class="docutils literal">ispc</tt> uses the following methods to try to find a match.  If
a single match of a given type is found, it is used; if multiple matches of
a given type are found, an error is issued.</p>
<ul class="simple">
<li>All parameter types match exactly.</li>
<li>All parameter types match exactly, where any <tt class="docutils literal">reference</tt>-qualified
parameters are considered equivalent to their underlying type.</li>
<li>Parameters match with only promotions from <tt class="docutils literal">uniform</tt> to <tt class="docutils literal">varying</tt>
type.</li>
<li>Parameters match using standard type conversion (<tt class="docutils literal">int</tt> to <tt class="docutils literal">float</tt>,
<tt class="docutils literal">float</tt> to <tt class="docutils literal">int</tt>.)</li>
</ul>
<p>Also like C, arrays are passed to functions by reference.</p>
</div>
<div class="section" id="c-constructs-not-in-ispc">
<h2>C Constructs not in ISPC</h2>
<p>The following C features are not available in <tt class="docutils literal">ispc</tt>.</p>
<ul class="simple">
<li><tt class="docutils literal">enum</tt> s</li>
<li>Pointers and function pointers</li>
<li><tt class="docutils literal">char</tt> and <tt class="docutils literal">short</tt> types</li>
<li><tt class="docutils literal">switch</tt> statements</li>
<li>bitfield members in structures</li>
<li><tt class="docutils literal">union</tt></li>
<li><tt class="docutils literal">goto</tt></li>
</ul>
</div>
</div>
<div class="section" id="parallel-execution-model-in-ispc">
<h1>Parallel Execution Model in ISPC</h1>
<p>Though <tt class="docutils literal">ispc</tt> has C-based syntax, it is inherently a language for
parallel computation.  Understanding the details of <tt class="docutils literal">ispc</tt>'s parallel
execution model is critical for writing efficient and correct programs in
<tt class="docutils literal">ispc</tt>.</p>
<p><tt class="docutils literal">ispc</tt> supports both task parallelism to parallelize across multiple
cores and SPMD parallelism to parallelize across the SIMD vector lanes on a
single core.  This section focuses on SPMD parallelism.  See the section
<a class="reference internal" href="#task-parallelism-in-ispc">Task Parallelism in ISPC</a> for discussion of task parallelism in <tt class="docutils literal">ispc</tt>.</p>
<div class="section" id="the-spmd-on-simd-execution-model">
<h2>The SPMD-on-SIMD Execution Model</h2>
<p>In the SPMD model as implemented in <tt class="docutils literal">ispc</tt>, you programs that compute a
set of outputs based on a set of inputs.  You must write these
programs so that it is safe to run multiple instances of them in
parallel--i.e. given a program an a set of inputs, the programs shouldn't
have any assumptions about the order in which they will be run over the
inputs, whether one program instances will have completed before another
runs. <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is essentially the same requirement that languages like CUDA*
and OpenCL* place on the programmer.</td></tr>
</tbody>
</table>
<p>Given this guarantee, the <tt class="docutils literal">ispc</tt> compiler can safely execute multiple
program instances in parallel, across the SIMD lanes of a single CPU.  In
many cases, this execution approach can achieve higher overall performance
than if the program instances had been run serially.</p>
<p>Upon entry to a <tt class="docutils literal">ispc</tt> function, the execution model switches from
the application's serial model to SPMD.  Conceptually, a number of
<tt class="docutils literal">ispc</tt> program instances will start running in parallel.  This
parallelism doesn't involve launching hardware threads.  Rather, one
program instance is mapped to each of the SIMD lanes of the CPU's vector
unit (Intel® SSE or Intel® AVX).</p>
<p>If a <tt class="docutils literal">ispc</tt> program is written to do a the following computation:</p>
<pre class="literal-block">
float x = ..., y = ...;
return x+y;
</pre>
<p>and if the <tt class="docutils literal">ispc</tt> program is running four-wide on a CPU that supports the
Intel® SSE instructions, then four program instances are running in
parallel, each adding a pair of scalar values.  However, these four program
instances store their individual scalar values for <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt> in the
lanes of an Intel® SSE vector register, so the addition operation for all
four program instances can be done in parallel with a single <tt class="docutils literal">addps</tt>
instruction.</p>
<p>Program execution is more complicated in the presence of control flow.  The
details are handled by the <tt class="docutils literal">ispc</tt> compiler, but you may find it helpful
to understand what is going on in order to be a more effective <tt class="docutils literal">ispc</tt>
programmer.  In particular, the mapping of SPMD to SIMD lanes can lead to
reductions in this SIMD efficiency as different program instances want to
perform different computations.  For example, consider a simple <tt class="docutils literal">if</tt>
statement:</p>
<pre class="literal-block">
float x = ..., y = ...;
if (x &lt; y) {
   ...
} else {
   ...
}
</pre>
<p>In general, the test <tt class="docutils literal">x&lt;y</tt> has a different result for different running
SPMD program instances.  Some of the currently running program instances
want to execute the statements for the &quot;true&quot; case and some want to execute
the statements for the &quot;false&quot; case.  <tt class="docutils literal">ispc</tt> processes this case by
generating code that executes for both cases and masking the results, such
that the &quot;true&quot; code doesn't have any side effects for the program
instances that want to run the &quot;false&quot; code, and vice versa.  Thus, the
correct reusult is computed for all of the program instances in the end,
though with some overhead relative to a scalar implementation where code
for only one of the two cases needs to run.</p>
<p><tt class="docutils literal">for</tt>, <tt class="docutils literal">while</tt>, and <tt class="docutils literal">do</tt> statements are similar.  Their loops must
run until all of the running SPMD program instances are ready to exit the
loop.  Thus in an extreme case of a loop like:</p>
<pre class="literal-block">
// assume limit has the values (1,1,1,1000) for the
// current running program instances
int limit = ...;
for (int i = 0; i &lt; limit; ++i) {
    ...
}
</pre>
<p>The loop body needs to execute 1000 times, since one of the SPMD
program instances has a value of 1000 for <tt class="docutils literal">limit</tt>.  For the other three
running program instances, the right result will still be computed, as the
code run the additional 999 times won't have any side effects for them.  However,
the result will have poor SIMD utilization as the majority of the loop
iterations don't benefit three out of the four currently running program
instances.  Thus, finding ways to structure the computation
so that the currently running program instances have similar desired
control flow paths leads to better overall efficiency.</p>
</div>
<div class="section" id="uniform-and-varying-qualifiers">
<h2>Uniform and Varying Qualifiers</h2>
<p>To write high-performance code, you need to understand the distinction
between <tt class="docutils literal">uniform</tt> and <tt class="docutils literal">varying</tt> data types.</p>
<p>If a variable has a <tt class="docutils literal">uniform</tt> qualifier, then there is only a single
instance of that variable for all of the currently-executing program
instances.  (As such, it necessarily has the same value across all of the
program instances.)  <tt class="docutils literal">uniform</tt> variables can be modified as the program
executes, but only in ways that preserve the property that they have the
same value across all of the program instances.  Assigning a
non-<tt class="docutils literal">uniform</tt> (i.e., <tt class="docutils literal">varying</tt>) value to a <tt class="docutils literal">uniform</tt> variable causes
a compile-time error.</p>
<p>When appropriate, declaring variables as <tt class="docutils literal">uniform</tt> types can allow the
compiler to produce substantially better code.  Consider for example an
image filtering operation where the program loops over adjacent pixels:</p>
<pre class="literal-block">
float box3x3(uniform float image[32][32], int x, int y) {
    float sum = 0;
    for (int dy = -1; dy &lt;= 1; ++dy)
        for (int dx = -1; dx &lt;= 1; ++dx)
            sum += image[y+dy][x+dx];
    return sum / 9.;
}
</pre>
<p>Under the SPMD execution model, a number of program instances are running
this function in parallel (and in general, we will assume that this
function will end up being called with different values for <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt>
for the running program instances.)  However, all of the program instances
will want to execute the same number of iterations of the <tt class="docutils literal">for</tt> loops,
with all of them having the same values for <tt class="docutils literal">dx</tt> and <tt class="docutils literal">dy</tt> each time
through. <a class="footnote-reference" href="#id4" id="id3">[2]</a></p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>In this case, a sufficiently smart compiler could determine that
<tt class="docutils literal">dx</tt> and <tt class="docutils literal">dy</tt> have the same value for all program instances and thus
generate more optimized code from the start, though <tt class="docutils literal">ispc</tt> isn't yet
this clever.  Put another way, the <tt class="docutils literal">ispc</tt> approach is generally that
the programmer shouldn't have to wonder if the compiler was smart or not
in a particular case, thus avoiding performance surprises.</td></tr>
</tbody>
</table>
<p>If these are instead implemented with <tt class="docutils literal">dx</tt> and <tt class="docutils literal">dy</tt> declared as
<tt class="docutils literal">uniform</tt> variables, then the <tt class="docutils literal">ispc</tt> compiler can generate more
efficient code for the loops, taking advantage of the fact that these
values are the same for all program instances.</p>
<pre class="literal-block">
for (uniform int dy = -1; dy &lt;= 1; ++dy)
    for (uniform int dx = -1; dx &lt;= 1; ++dx)
        sum += image[y+dy][x+dx];
</pre>
<p>In particular, <tt class="docutils literal">ispc</tt> can avoid the overhead of checking to see if any
of the running program instances wants to do another loop iteration.
Instead, <tt class="docutils literal">ispc</tt> can
generate code where all instances always do the same iterations.</p>
<p>A related benefit comes in <tt class="docutils literal">if</tt> statements--if the test in an <tt class="docutils literal">if</tt>
statement is purely based on <tt class="docutils literal">uniform</tt> quantities, then the result will
by definition be the same for all of the running program instances. Thus,
the code for only one of the two cases needs to execute.  <tt class="docutils literal">ispc</tt> can
generate code that jumps to one of the two, avoiding the overhead of
needing to run the code for both cases.</p>
<p><tt class="docutils literal">uniform</tt> variables will implicitly type-convert to varying types as
required:</p>
<pre class="literal-block">
uniform int x = ...;
int y = ...;
int z = x * y;
</pre>
<p>Conversely, it is a compile-time error to assign a varying value to a
<tt class="docutils literal">uniform</tt> type:</p>
<pre class="literal-block">
float f = ....;
uniform float uf = f;  // ERROR
</pre>
<p>Arrays themselves aren't uniform or varying, but the elements that they
store are:</p>
<pre class="literal-block">
float foo[10];
uniform float bar[10];
</pre>
<p>Continuing the connection to data types in memory, the first declaration
corresponds to 10 four-wide float values (on Intel® SSE), and the second to
10 single float values.</p>
</div>
<div class="section" id="mapping-data-to-program-instances">
<h2>Mapping Data to Program Instances</h2>
<p>An important part of SPMD programming is how to map the set of running
instances to the set of inputs to the program.</p>
<p>If the application has created an array of floating-point values on which
the following computation needs to be completed:</p>
<pre class="literal-block">
// C++ code
int count = ...;
float *data = new float[count];
float *result = new float[count];
... initialize data ...
ispc_func(data, count, result);
</pre>
<p>And if we have a <tt class="docutils literal">ispc</tt> function declared as follows, then, given a
number of program instances running in parallel, how do the program
instances determine which elements of the array to work on?</p>
<pre class="literal-block">
// ispc code
export void ispc_func(uniform float data[],
                      uniform int count,
                      uniform float result[]) {
    ...
</pre>
<p><tt class="docutils literal">ispc</tt> provides two built-in variables to help with this data mapping
across the set of running SPMD program instances.  The first,
<tt class="docutils literal">programCount</tt> gives the number of program instances that are executing
in parallel; for example, it may have the value 4 on most targets that
support Intel® and 8 on targets that support Intel® AVX.  The second,
<tt class="docutils literal">programIndex</tt>, gives the index of the SIMD-lane being used for the
current program instance.  (In other words, it's a varying integer value
that has value zero for the first program instance, and so forth.)</p>
<p>Given these, <tt class="docutils literal">ispc_func</tt> might be implemented as:</p>
<pre class="literal-block">
for (uniform int i = 0; i &lt; count; i += programCount) {
    float d = data[i + programIndex];
    float r = ....
    result[i + programIndex] = r;
}
</pre>
<p>This code implicitly assumes that <tt class="docutils literal">programCount</tt> evenly divides
<tt class="docutils literal">count</tt>.  The more general case could be:</p>
<pre class="literal-block">
for (uniform int i = 0; i &lt; count; i += programCount) {
    if (i + programIndex &lt; programCount) {
        float d = data[i + programIndex];
        ...
</pre>
<p>Some performance improvement may come from removing the <tt class="docutils literal">if</tt> test from
the loop:</p>
<pre class="literal-block">
uniform int fullCount = count - (count % programCount);
uniform int i;
for (i = 0; i &lt; fullCount; i += programCount) {
    float d = data[i + programIndex];
     ...
}
if (i + programIndex &lt; count) {
    float d = data[i + programIndex];
    ...
}
</pre>
<p>For a more complex example, consider a ray tracer that wants to trace 4
rays per pixel.  To write code that works on one pixel at a time on a
machine that supports Intel® SSE, and 2 pixels at a time on a machine that
supports Intel® AVX, see the following:</p>
<pre class="literal-block">
// compute sample offsets for the pixel or pixels being processed
uniform float xOffsetBase[4] = { 0, 0, 0.5, 0.5 };
uniform float yOffsetBase[4] = { 0, 0.5, 0, 0.5 };
float xOffset[programIndex % 4], yOffset[programIndex % 4];

// compute steps
uniform int dx, dy;
if (programCount == 4) { dx = dy = 1; }
else if (programCount == 8) {
    dx = 2; dy = 1;
    xOffset += programIndex / 4;
}
else if (programCount == 16) {
    xOffset += programIndex / 8;
    yOffset += (programIndex / 4) &amp; 0x1;
    dx = dy = 2;
}

for (uniform int y = 0; y &lt; height; y += dy) {
   for (uniform int x = 0; x &lt; width; x += dx) {
       float xSample = x + xOffset, ySample = y + yOffset;
       // process samples in parallel ...
   }
}
</pre>
</div>
<div class="section" id="coherent-control-flow-statements">
<h2>&quot;Coherent&quot; Control Flow Statements</h2>
<p><tt class="docutils literal">ispc</tt> provides a few mechanisms for you to supply a hint that control
flow is expected to be coherent at a particular point in the program's
execution.  These mechanisms provide the compiler a hint that it's worth
emitting extra code to check to see if the control flow is in fact coherent
at run-time, in which case it can jump to a simpler code path or otherwise
save work.</p>
<p>The first of these statements is <tt class="docutils literal">cif</tt>, indicating an <tt class="docutils literal">if</tt> statement
that is expected to be coherent.  Recall from the <a class="reference internal" href="#the-spmd-on-simd-execution-model">The
SPMD-on-SIMD Execution Model</a> section that <tt class="docutils literal">if</tt> statements with a
<tt class="docutils literal">uniform</tt> test compile to more efficient code than <tt class="docutils literal">if</tt> tests with
varying tests.  <tt class="docutils literal">cif</tt> can provide many benefits of <tt class="docutils literal">if</tt> with a
uniform test in the case where the test is actually varying.</p>
<p>The usage of <tt class="docutils literal">cif</tt> in code is just the same as <tt class="docutils literal">if</tt>:</p>
<pre class="literal-block">
cif (x &lt; y) {
    ...
} else {
    ...
}
</pre>
<p><tt class="docutils literal">cif</tt> provides a hint to the compiler that you expect that most of the
executing SPMD programs will all have the same result for the <tt class="docutils literal">if</tt>
condition.  In this case, the code the compiler generates for the <tt class="docutils literal">if</tt>
test is along the lines of the following pseudo-code:</p>
<pre class="literal-block">
bool expr = /* evaluate cif condition */
if (all(expr)) {
    // run &quot;true&quot; case of if test only
} else if (!any(expr)) {
    // run &quot;false&quot; case of if test only
} else {
    // run both true and false cases, updating mask appropriately
}
</pre>
<p>(For comparison, see the discussion of how regular <tt class="docutils literal">if</tt> statements are
executed from the <a class="reference internal" href="#the-spmd-on-simd-execution-model">The SPMD-on-SIMD Execution Model</a>
section.)</p>
<p>For <tt class="docutils literal">if</tt> statements where the different running SPMD program instances
don't have coherent values for the boolean <tt class="docutils literal">if</tt> test, using <tt class="docutils literal">cif</tt>
introduces some additional overhead from the <tt class="docutils literal">all</tt> and <tt class="docutils literal">any</tt> tests as
well as the corresponding branches.  For cases where the the program
instances often do compute the same boolean value, this overhead is
worthwhile.  If the control flow is in fact usually incoherent, this
overhead only costs performance.</p>
<p>In a similar fashion, <tt class="docutils literal">ispc</tt> provides <tt class="docutils literal">cfor</tt>, <tt class="docutils literal">cwhile</tt>, <tt class="docutils literal">cdo</tt>,
<tt class="docutils literal">cbreak</tt>, <tt class="docutils literal">ccontinue</tt>, and <tt class="docutils literal">creturn</tt> statements.  These statements
are semantically the same as the corresponding non-&quot;c&quot;-prefixed functions.</p>
<p>For example, when <tt class="docutils literal">ispc</tt> encounters a regular <tt class="docutils literal">continue</tt> statement in
the middle of loop, it disables the mask bits for the program instances
that executed the <tt class="docutils literal">continue</tt> and then executes the remainder of the loop
body, under the expectation that other executing program instances will
still need to run those instructions.  If you expect that all running
program instances will often execute <tt class="docutils literal">continue</tt> together, then
<tt class="docutils literal">ccontinue</tt> provides the compiler a hint to do extra work to check if
every running program instance continued, in which case it can jump to the
end of the loop, saving the work of executing the otherwise meaningless
instructions.</p>
</div>
<div class="section" id="program-instance-convergence">
<h2>Program Instance Convergence</h2>
<p>Unlike languages such as OpenCL* and CUDA*, these executing program
instances are guaranteed to be maximally converged--if two program
instances follow the same control path, they are guaranteed to execute each
operation at the same time.  In the presence of divergent control flow:</p>
<pre class="literal-block">
if (test) {
  // true
}
else {
  // false
}
</pre>
<p>It is guaranteed that all program instances that were running before the
<tt class="docutils literal">if</tt> test will also be running after the end of the <tt class="docutils literal">else</tt> block.
There is thus no need for a <tt class="docutils literal">syncthreads</tt>--type construct to synchronize
the executing program instances in cases where program instances would like
to share data or commicate with each other.</p>
</div>
<div class="section" id="data-races">
<h2>Data Races</h2>
<p>Although the SPMD model assumes that program instances are independent, you
can write code that has data races across the program instances.  For
example, the following code causes all program instances to try to write
different values to the same location:</p>
<pre class="literal-block">
uniform int array[32] = 0;
int index = 0;
array[index] = programIndex;
</pre>
<p>In this case, the behavior of the program is undefined.</p>
</div>
<div class="section" id="uniform-variables-and-varying-control-flow">
<h2>Uniform Variables and Varying Control Flow</h2>
<p>Operations may be executed even if none of the program instances needs to
run them based on their control flow.  Consider an <tt class="docutils literal">if</tt>/<tt class="docutils literal">else</tt> test;
the statements in the <tt class="docutils literal">else</tt> block may be executed even if the test
evaluates to <tt class="docutils literal">true</tt> for all of the running program instances.  In
general, the executed statements are masked, such that they have no side
effects for the program instances that don't want to be running them, so
there is no visible side-effect of executing the <tt class="docutils literal">else</tt> statements.
There is, however, one case where this part of the execution model can
become apparent.</p>
<p>Consider the cast of modifying the value of a <tt class="docutils literal">uniform</tt> variable under
varying control flow:</p>
<pre class="literal-block">
extern void foo();
uniform int a;

if (test) { // varying test
    ++a;    // modifying uniform under varying control flow
    foo();
}
</pre>
<p>When possible, <tt class="docutils literal">ispc</tt> detects that the control flow is varying and issues
an warning if a uniform variable is modified in this case.  Here, <tt class="docutils literal">a</tt> may
be modified in the above code even if <em>none</em> of the program instances
evaluated a true value for the test, given the <tt class="docutils literal">ispc</tt> execution model.</p>
</div>
<div class="section" id="task-parallelism-in-ispc">
<h2>Task Parallelism in ISPC</h2>
<p>One option for combining task-parallelism with <tt class="docutils literal">ispc</tt> is to just use
regular task parallelism in the C/C++ application code (be it through
Intel® Cilk(tm), Intel® Thread Building Blocks or another task system,
etc.), and for tasks to use <tt class="docutils literal">ispc</tt> for SPMD parallelism across the vector
lanes as appropriate.  Alternatively, <tt class="docutils literal">ispc</tt> also has some support for
launching tasks from <tt class="docutils literal">ispc</tt> code.  The approach is similar to Intel®
Cilk's task launch feature.  (See the <tt class="docutils literal">examples/mandelbrot_tasks</tt> example
to see it used in a non-trivial example.)</p>
<p>Any function that is launched as a task must be declared with the <tt class="docutils literal">task</tt>
qualifier:</p>
<pre class="literal-block">
task void func(uniform float a[], uniform int start) {
    ....
}
</pre>
<p>Tasks must return <tt class="docutils literal">void</tt>; a compile time error is issued if a
non-<tt class="docutils literal">void</tt> task is defined.</p>
<p>Given a task, one can then write code that launches tasks as follows:</p>
<pre class="literal-block">
for (uniform int i = 0; i &lt; 100; ++i)
    launch &lt; func(a, i); &gt;
</pre>
<p>Note the <tt class="docutils literal">launch</tt> keyword and the brackets around the function call.
This code launches 100 tasks, each of which presumably does some
computation keyed off of given the value <tt class="docutils literal">i</tt>.  In general, one should
launch many more tasks than there are processors in the system to
ensure good load-balancing, but not so many that the overhead of scheduling
and running tasks dominates the computation.</p>
<p>Program execution continues asynchronously after task launch; thus, the
function shouldn't access values being generated by the tasks without
synchronization.  A function uses a <tt class="docutils literal">sync</tt> statement to wait for all
launched tasks to finish:</p>
<pre class="literal-block">
for (uniform int i = 0; i &lt; 100; ++i)
    launch &lt; func(a, i); &gt;
sync;
// now safe to use computed values in a[]...
</pre>
<p>Alternatively, any function that launches tasks has an implicit <tt class="docutils literal">sync</tt>
before it returns, so that functions that call a function that launches
tasks don't have to worry about outstanding asynchronous computation.</p>
<p>Inside functions with the <tt class="docutils literal">task</tt> qualifier, two additional built-in
variables are provided: <tt class="docutils literal">threadIndex</tt> and <tt class="docutils literal">threadCount</tt>.
<tt class="docutils literal">threadCount</tt> gives the total number of hardware threads that have been
launched by the task system.  <tt class="docutils literal">threadIndex</tt> provides an index between
zero and <tt class="docutils literal"><span class="pre">threadCount-1</span></tt> that gives a unique index that corresponds to
the hardware thread that is executing the current task.  The
<tt class="docutils literal">threadIndex</tt> can be used for accessing data that is private to the
current thread and thus doesn't require synchronization to access under
parallel execution.</p>
<p>If you use the task launch feature in <tt class="docutils literal">ispc</tt>, you must provide C/C++
implementations of two functions and link them into your final executable
file:</p>
<pre class="literal-block">
void ISPCLaunch(void *funcptr, void *data);
void ISPCSync();
</pre>
<p>These are called by the task launch code generated by the <tt class="docutils literal">ispc</tt>
compiler; the first is called to launch to launch a task and the second is
called to wait for, respectively.  (Factoring them out in this way
allows <tt class="docutils literal">ispc</tt> to inter-operate with the application's task system, if
any, rather than having a separate one of its own.)  To run a particular
task, the task system should cast the function pointer to a <tt class="docutils literal">void <span class="pre">(*)(void</span>
*, int, int)</tt> function pointer and then call it with the provided <tt class="docutils literal">void
*</tt> data and then an index for the current hardware thread and the total
number of hardware threads the task system has launched--in other words:</p>
<pre class="literal-block">
typedef void (*TaskFuncType)(void *, int, int);
TaskFuncType tft = (TaskFuncType)(funcptr);
tft(data, threadIndex, threadCount);
</pre>
<p>A number of sample task system implementations are provided with <tt class="docutils literal">ispc</tt>;
see the files <tt class="docutils literal">tasks_concrt.cpp</tt>, <tt class="docutils literal">tasks_gcd.cpp</tt> and
<tt class="docutils literal">tasks_pthreads.cpp</tt> in the <tt class="docutils literal">examples/mandelbrot_tasks</tt> directory of
the <tt class="docutils literal">ispc</tt> distribution.</p>
</div>
</div>
<div class="section" id="the-ispc-standard-library">
<h1>The ISPC Standard Library</h1>
<p><tt class="docutils literal">ispc</tt> has a standard library that is automatically available when
compiling <tt class="docutils literal">ispc</tt> programs.  (To disable the standard library, pass the
<tt class="docutils literal"><span class="pre">--nostdlib</span></tt> command-line flag to the compiler.)</p>
<div class="section" id="math-functions">
<h2>Math Functions</h2>
<p>The math functions in the standard library provide a relatively standard
range of mathematical functionality.</p>
<p>A number of different implementations of the transcendental math functions
are available; the math library to use can be selected with the
<tt class="docutils literal"><span class="pre">--math-lib=</span></tt> command line argument.  The following values can be provided
for this argument.</p>
<ul class="simple">
<li><tt class="docutils literal">default</tt>: <tt class="docutils literal">ispc</tt>'s default built-in math functions.  These have
reasonably high precision. (e.g. <tt class="docutils literal">sin</tt> has a maximum absolute error of
approximately 1.45e-6 over the range -10pi to 10pi.)</li>
<li><tt class="docutils literal">fast</tt>: more efficient but lower accuracy versions of the default <tt class="docutils literal">ispc</tt>
implementations.</li>
<li><tt class="docutils literal">svml</tt>: use Intel &quot;Short Vector Math Library&quot;.  Use
<tt class="docutils literal">icc</tt> to link your final executable so that the appropriate libraries
are linked.</li>
<li><tt class="docutils literal">system</tt>: use the system's math library.  On many systems, these
functions are more accurate than both of <tt class="docutils literal">ispc</tt>'s implementations.
Using these functions may be quite
inefficient; the system math functions only compute one result at a time
(i.e. they aren't vectorized), so <tt class="docutils literal">ispc</tt> has to call them once per
active program instance.  (This is not the case for the other three
options.)</li>
</ul>
<p>In addition to an absolute value call, <tt class="docutils literal">abs()</tt>, <tt class="docutils literal">signbits()</tt> extracts
the sign bit of the given value, returning <tt class="docutils literal">0x80000000</tt> if the sign bit
is on (i.e. the value is negative) and zero if it is off.</p>
<pre class="literal-block">
float abs(float a)
uniform float abs(uniform float a)
unsigned int signbits(float x)
</pre>
<p>Standard rounding functions are provided.  (On machines that support Intel®
SSE or Intel® AVX, these functions all map to variants of the <tt class="docutils literal">roundss</tt> and
<tt class="docutils literal">roundps</tt> instructions, respectively.)</p>
<pre class="literal-block">
float round(float x)
uniform float round(uniform float x)
float floor(float x)
uniform float floor(uniform float x)
float ceil(float x)
uniform float ceil(uniform float x)
</pre>
<p><tt class="docutils literal">rcp()</tt> computes an approximation to <tt class="docutils literal">1/v</tt>.  The amount of error is
different on different architectures.</p>
<pre class="literal-block">
float rcp(float v)
uniform float rcp(uniform float v)
</pre>
<p>The square root of a given value can be computed with <tt class="docutils literal">sqrt()</tt>, which
maps to hardware square root intrinsics when available.  An approximate
reciprocal square root, <tt class="docutils literal">1/sqrt(v)</tt> is computed by <tt class="docutils literal">rsqrt()</tt>.  Like
<tt class="docutils literal">rcp()</tt>, the error from this call is different on different
architectures.</p>
<pre class="literal-block">
float sqrt(float v)
uniform float sqrt(uniform float v)
float rsqrt(float v)
uniform float rsqrt(uniform float v)
</pre>
<p>A standard set of minimum and maximum functions is available.  These
functions also map to corresponding intrinsic functions.</p>
<pre class="literal-block">
float min(float a, float b)
uniform float min(uniform float a, uniform float b)
float max(float a, float b)
uniform float max(uniform float a, uniform float b)
unsigned int min(unsigned int a, unsigned int b)
uniform unsigned int min(uniform unsigned int a,
                         uniform unsigned int b)
unsigned int max(unsigned int a, unsigned int b)
uniform unsigned int max(uniform unsigned int a,
                         uniform unsigned int b)
</pre>
<p>The <tt class="docutils literal">clamp()</tt> functions clamp the provided value to the given range.
(Their implementations are based on <tt class="docutils literal">min()</tt> and <tt class="docutils literal">max()</tt> and are thus
quite efficient.)</p>
<pre class="literal-block">
float clamp(float v, float low, float high)
uniform float clamp(uniform float v, uniform float low,
                    uniform float high)
unsigned int clamp(unsigned int v, unsigned int low,
                   unsigned int high)
uniform unsigned int clamp(uniform unsigned int v,
                           uniform unsigned int low,
                           uniform unsigned int high)
</pre>
<p><tt class="docutils literal">ispc</tt> provides a standard variety of calls for trigonometric functions:</p>
<pre class="literal-block">
float sin(float x)
uniform float sin(uniform float x)
float cos(float x)
uniform float cos(uniform float x)
float tan(float x)
uniform float tan(uniform float x)
</pre>
<p>Arctangent functions are also available:</p>
<pre class="literal-block">
float atan(float x)
float atan2(float x, float y)
uniform float atan(uniform float x)
uniform float atan2(uniform float x, uniform float y)
</pre>
<p>If both sine and cosine are needed, then the <tt class="docutils literal">sincos()</tt> call computes
both more efficiently than two calls to the respective individual
functions:</p>
<pre class="literal-block">
void sincos(float x, reference float s, reference float c)
void sincos(uniform float x, uniform reference float s,
            uniform reference float c)
</pre>
<p>The usual exponential and logarithmic functions are provided.</p>
<pre class="literal-block">
float exp(float x)
uniform float exp(uniform float x)
float log(float x)
uniform float log(uniform float x)
float pow(float a, float b)
uniform float pow(uniform float a, uniform float b)
</pre>
<p>Some functions that end up doing low-level manipulation of the
floating-point representation in memory are available.  As in the standard
math library, <tt class="docutils literal">ldexp()</tt> multiplies the value <tt class="docutils literal">x</tt> by 2^n, and
<tt class="docutils literal">frexp()</tt> directly returns the normalized mantissa and returns the
normalized exponent as a power of two in the <tt class="docutils literal">pw2</tt> parameter.</p>
<pre class="literal-block">
float ldexp(float x, int n)
uniform float ldexp(uniform float x, uniform int n)
float frexp(float x, reference int pw2)
niform float frexp(uniform float x,
                   reference uniform int pw2)
</pre>
<p>A simple random number generator is provided.  State for the RNG
is maintained in an instance of the <tt class="docutils literal">RNGState</tt> structure, which is seeded
with <tt class="docutils literal">seed_rng()</tt>.</p>
<pre class="literal-block">
struct RNGState;
unsigned int random(reference uniform RNGState state)
float frandom(reference uniform RNGState state)
void seed_rng(reference uniform RNGState state,
              uniform int seed)
</pre>
</div>
<div class="section" id="output-functions">
<h2>Output Functions</h2>
<p><tt class="docutils literal">ispc</tt> has a simple <tt class="docutils literal">print</tt> statement for printing values during
program execution.  In the following short <tt class="docutils literal">ispc</tt> program, there are
three uses of the <tt class="docutils literal">print</tt> statement:</p>
<pre class="literal-block">
export void foo(uniform float f[4], uniform int i) {
    float x = f[programIndex];
    print(&quot;i = %, x = %\n&quot;, i, x);
    if (x &lt; 2) {
        ++x;
        print(&quot;added to x = %\n&quot;, x);
    }
    print(&quot;last print of x = %\n&quot;, x);
}
</pre>
<p>There are a few things to note.  First, the function is called <tt class="docutils literal">print</tt>,
not <tt class="docutils literal">printf</tt> (unlike C).  Second, the formatting string passed to this
function only uses a single percent sign to denote where the corresponding
value should be printed.  You don't need to match the types of formatting
operators with the types being passed.  However, you can't currently use
the rich data formatting options that <tt class="docutils literal">printf</tt> provides (e.g. constructs
like <tt class="docutils literal">%.10f</tt>.).</p>
<p>If this function is called with the array of floats (0,1,2,3) passed in for
the <tt class="docutils literal">f</tt> parameter and the value <tt class="docutils literal">10</tt> for the <tt class="docutils literal">i</tt> parameter, it
generates the following output on a four-wide compilation target:</p>
<pre class="literal-block">
i = 10, x = [0.000000,1.000000,2.000000,3.000000]
added to x = [1.000000,2.000000,_________,_________]
last print of x = [1.000000,2.000000,2.000000,3.000000]
</pre>
<p>All values of &quot;varying&quot; variables for each executing program instance is
printed when a &quot;varying&quot; variable is printed.  The result from the second
print statement, which was called under control flow in the function
<tt class="docutils literal">foo()</tt> above, and given the input array (0,1,2,3), only includes the
first two program instances entered the <tt class="docutils literal">if</tt> block.  Therefore, the
values for the inactive program instances aren't printed.  (In other cases,
they may have garbage values or be otherwise undefined.)</p>
</div>
<div class="section" id="cross-lane-operations">
<h2>Cross-Lane Operations</h2>
<p>Usually, <tt class="docutils literal">ispc</tt> code expresses independent computation on separate data
elements.  There are, however, a number of cases where it's useful for the
program instances to be able to cooperate in computing results.  The
cross-lane operations described in this section provide primitives for
communication between the running program instances.</p>
<p>A few routines that evaluate conditions across the running program
instances.  For example, <tt class="docutils literal">any()</tt> returns <tt class="docutils literal">true</tt> if the given value
<tt class="docutils literal">v</tt> is <tt class="docutils literal">true</tt> for any of the SPMD program instances currently running,
and <tt class="docutils literal">all()</tt> returns <tt class="docutils literal">true</tt> if it true for all of them.</p>
<pre class="literal-block">
uniform bool any(bool v)
uniform bool all(bool v)
</pre>
<p>The various variants of <tt class="docutils literal">popcnt()</tt> return the population count--the
number of bits set in the given value.</p>
<pre class="literal-block">
uniform int popcnt(uniform int v)
int popcnt(int v)
uniform int popcnt(bool v)
</pre>
<p>The <tt class="docutils literal">lanemask()</tt> function returns an integer that encodes which of the
current SPMD program instances are currently executing.  The i'th bit is
set if the i'th SIMD lane is currently active.</p>
<pre class="literal-block">
uniform int lanemask()
</pre>
<p>You can compute reductions across the program instances.  For example, the
values in each of the SIMD lanes <tt class="docutils literal">x</tt> are added together by
<tt class="docutils literal">reduce_add()</tt>.  If this function is called under control flow, it only
adds the values for the currently active program instances.</p>
<pre class="literal-block">
uniform float reduce_add(float x)
uniform int reduce_add(int x)
uniform unsigned int reduce_add(unsigned int x)
</pre>
<p>You can also use functions to compute the minimum and maximum value of the
given value across all of the currently-executing vector lanes.</p>
<pre class="literal-block">
uniform float reduce_min(float a, float b)
uniform int reduce_min(int a, int b)
uniform unsigned int reduce_min(unsigned int a, unsigned int b)
uniform float reduce_max(float a, float b)
uniform int reduce_max(int a, int b)
uniform unsigned int reduce_max(unsigned int a, unsigned int b)
</pre>
<p>Finally, there are routines for writing out and reading in values from
linear memory locations for the active program instances.
<tt class="docutils literal">packed_load_active()</tt> loads consecutive values from the given array,
starting at <tt class="docutils literal">a[offset]</tt>, loading one value for each currently-executing
program instance and storing it into that program instance's <tt class="docutils literal">val</tt>
variable.  It returns the total number of values loaded.  Similarly,
<tt class="docutils literal">packed_store_active()</tt> stores the <tt class="docutils literal">val</tt> values for each program
instances that executed the <tt class="docutils literal">packed_store_active()</tt> call, storing the
results into the given array starting at the given offset.  It returns the
total number of values stored.</p>
<pre class="literal-block">
uniform unsigned int packed_load_active(uniform int a[],
                                        uniform int offset,
                                        reference int val)
uniform unsigned int packed_store_active(uniform int a[],
                                         uniform int offset,
                                         int val)
</pre>
<p>As an example of how these functions can be used, the following code shows
the use of <tt class="docutils literal">packed_store_active()</tt>.  The program instances that are
executing each compute some value <tt class="docutils literal">x</tt>; we'd like to record the program
index values of the program instances for which <tt class="docutils literal">x</tt> is less than zero, if
any.  In following the code, the <tt class="docutils literal">programIndex</tt> value for each program
instance is written into the <tt class="docutils literal">ids</tt> array only if <tt class="docutils literal">x &lt; 0</tt> for that
program instance.  The total number of values written into <tt class="docutils literal">ids</tt> is
returned from <tt class="docutils literal">packed_store_active()</tt>.</p>
<pre class="literal-block">
uniform int ids[100];
uniform int offset = 0;
float x = ...;
if (x &lt; 0)
    offset += packed_store_active(ids, offset, programIndex);
</pre>
<p>Finally, there are primitive operations that extract and set values in the
SIMD lanes.  You can implement all of the operations described
above in this section from these routines, though in general, not as
efficiently.  These routines are useful for implementing other reductions
and cross-lane communication that isn't included in the above, though.
Given a <tt class="docutils literal">varying</tt> value, <tt class="docutils literal">extract()</tt> returns the i'th element of it as
a single <tt class="docutils literal">uniform</tt> value.  Similarly, <tt class="docutils literal">insert</tt> returns a new value
where the <tt class="docutils literal">i</tt> th element of <tt class="docutils literal">x</tt> has been replaced with the value <tt class="docutils literal">v</tt>
.</p>
<pre class="literal-block">
uniform float extract(float x, uniform int i)
uniform int extract(int x, uniform int i)
float insert(float x, uniform int i, uniform float v)
int insert(int x, uniform int i, uniform int v)
</pre>
</div>
<div class="section" id="low-level-bits">
<h2>Low-Level Bits</h2>
<p><tt class="docutils literal">ispc</tt> provides a number of bit/memory-level utility routines in its
standard library as well.  It has routines that load from and store
to 8-bit and 16-bit integer values stored in memory, converting to and from
32-bit integers for use in computation in <tt class="docutils literal">ispc</tt> code.  (These functions
and this conversion step are necessary because <tt class="docutils literal">ispc</tt> doesn't have native
8-bit or 16-bit types in the language.)</p>
<pre class="literal-block">
unsigned int load_from_int8(uniform int a[],
                            uniform int offset)
void store_to_int8(uniform int a[], uniform int offset,
                   unsigned int val)
unsigned int load_from_int16(uniform int a[],
                             uniform int offset)
void store_to_int16(uniform int a[], uniform int offset,
                    unsigned int val)
</pre>
<p>There are two things to note in these functions.  First, note that these
functions take <tt class="docutils literal">unsigned int</tt> arrays as parameters; you need
to cast <cite>the ``int8_t`</cite> and <tt class="docutils literal">int16_t</tt> pointers from the C/C++ side to
<tt class="docutils literal">unsigned int</tt> when passing them to <tt class="docutils literal">ispc</tt> code.  Second, although the
arrays are passed as <tt class="docutils literal">unsigned int</tt>, in the array indexing calculation,
with the <tt class="docutils literal">offset</tt> parameter, they are treated as if they were <tt class="docutils literal">int8</tt> or
<tt class="docutils literal">int16</tt> types.  (i.e. the offset treated as being in terms of number of 8
or 16-bit elements.)</p>
<p>The <tt class="docutils literal">intbits()</tt> and <tt class="docutils literal">floatbits()</tt> functions can be used to implement
low-level floating-point bit twiddling.  For example, <tt class="docutils literal">intbits()</tt> returns
an <tt class="docutils literal">unsigned int</tt> that is a bit-for-bit copy of the given <tt class="docutils literal">float</tt>
value.  (Note: it is <strong>not</strong> the same as <tt class="docutils literal">(int)a</tt>, but corresponds to
something like <tt class="docutils literal"><span class="pre">*((int</span> <span class="pre">*)&amp;a)</span></tt> in C.</p>
<pre class="literal-block">
float floatbits(unsigned int a);
uniform float floatbits(uniform unsigned int a);
unsigned int intbits(float a);
uniform unsigned int intbits(uniform float a);
</pre>
<p>The <tt class="docutils literal">intbits()</tt> and <tt class="docutils literal">floatbits()</tt> functions have no cost at runtime;
they just let the compiler know how to interpret the bits of the given
value.  They make it possible to efficiently write functions that take
advantage of the low-level bit representation of floating-point values.</p>
<p>For example, the <tt class="docutils literal">abs()</tt> function in the standard library is implemented
as follows:</p>
<pre class="literal-block">
float abs(float a) {
    unsigned int i = intbits(a);
    i &amp;= 0x7fffffff;
    return floatbits(i);
}
</pre>
<p>It, it clears the high order bit, to ensure that the given floating-point
value is positive.  This compiles down to a single <tt class="docutils literal">andps</tt> instruction
when used with an Intel® SSE target, for example.</p>
</div>
</div>
<div class="section" id="interoperability-with-the-application">
<h1>Interoperability with the Application</h1>
<p>One of <tt class="docutils literal">ispc</tt>'s key goals is to make it easy to interoperate between the
C/C++ application code and parallel code written in <tt class="docutils literal">ispc</tt>.  This
section describes the details of how this works and describes a number of
the pitfalls.</p>
<div class="section" id="interoperability-overview">
<h2>Interoperability Overview</h2>
<p>As described in <a class="reference internal" href="#compiling-and-running-a-simple-ispc-program">Compiling and Running a Simple ISPC Program</a> it's
relatively straightforward to call <tt class="docutils literal">ispc</tt> code from C/C++.  First, any
<tt class="docutils literal">ispc</tt> functions to be called should be defined with the <tt class="docutils literal">export</tt>
keyword:</p>
<pre class="literal-block">
export void foo(uniform float a[]) {
    ...
}
</pre>
<p>This function corresponds to the following C-callable function:</p>
<pre class="literal-block">
void foo(float a[]);
</pre>
<p>(Recall from the <a class="reference internal" href="#uniform-and-varying-qualifiers">Uniform and Varying Qualifiers</a> section
that <tt class="docutils literal">uniform</tt> types correspond to a single instances of the
corresponding type in C/C++.)</p>
<p>In addition to variables passed from the application to <tt class="docutils literal">ispc</tt> in the
function call, you can also share global variables between the application
and <tt class="docutils literal">ispc</tt>.  To do so, just declare the global variable as usual (in
either <tt class="docutils literal">ispc</tt> or application code), and add an <tt class="docutils literal">extern</tt> declaration on
the other side.</p>
<p>For example, given this <tt class="docutils literal">ispc</tt> code:</p>
<pre class="literal-block">
// ispc code
uniform float foo;
extern uniform float bar[10];
</pre>
<p>And this C++ code:</p>
<pre class="literal-block">
// C++ code
extern float foo;
float bar[10];
</pre>
<p>Both the <tt class="docutils literal">foo</tt> and <tt class="docutils literal">bar</tt> global variables can be accessed on each
side.</p>
<p><tt class="docutils literal">ispc</tt> code can also call back to C/C++.  On the <tt class="docutils literal">ispc</tt> side, any
application functions to be called must be declared with the <tt class="docutils literal">export &quot;C&quot;</tt>
qualifier.</p>
<pre class="literal-block">
extern &quot;C&quot; void foo(uniform float f, uniform float g);
</pre>
<p>Unlike in C++, <tt class="docutils literal">export &quot;C&quot;</tt> doesn't take braces to delineate
multiple functions to be declared; thus, multiple C functions to be called
from <tt class="docutils literal">ispc</tt> must be declared as follows:</p>
<pre class="literal-block">
extern &quot;C&quot; void foo(uniform float f, uniform float g);
extern &quot;C&quot; uniform int bar(uniform int a);
</pre>
<p>It is illegal to overload functions declared with <tt class="docutils literal">extern &quot;C&quot;</tt> linkage;
<tt class="docutils literal">ispc</tt> issues an error in this case.</p>
<p>Function calls back to C/C++ are not made if none of the program instances
want to make the call.  For example, given code like:</p>
<pre class="literal-block">
uniform float foo = ...;
float x = ...;
if (x != 0)
    foo = appFunc(foo);
</pre>
<p><tt class="docutils literal">appFunc()</tt> will only be called if one or more of the running program
instances evaluates <tt class="docutils literal">true</tt> for <tt class="docutils literal">x != 0</tt>.  If the application code would
like to determine which of the running program instances want to make the
call, a mask representing the active SIMD lanes can be passed to the
function.</p>
<pre class="literal-block">
extern &quot;C&quot; float appFunc(uniform float x,
                         uniform int activeLanes);
</pre>
<p>If the function is then called as:</p>
<pre class="literal-block">
...
x = appFunc(x, lanemask());
</pre>
<p>The <tt class="docutils literal">activeLanes</tt> parameter will have the value one in the 0th bit if the
first program instance is running at this point in the code, one in the
first bit for the second instance, and so forth.  (The <tt class="docutils literal">lanemask()</tt>
function is documented in <a class="reference internal" href="#low-level-bits">Low-Level Bits</a>.)  Application code can thus be
written as:</p>
<pre class="literal-block">
float appFunc(float x, int activeLanes) {
    for (int i = 0; i &lt; programCount; ++i)
        if ((activeLanes &amp; (1 &lt;&lt; i)) != 0) {
            // do computation for i'th SIMD lane
        }
}
</pre>
</div>
<div class="section" id="data-layout">
<h2>Data Layout</h2>
<p>In general, <tt class="docutils literal">ispc</tt> tries to ensure that <tt class="docutils literal">struct</tt> s and other complex
datatypes are laid out in the same way in memory as they are in C/C++.
Matching alignment is important for easy interoperability between C/C++
code and <tt class="docutils literal">ispc</tt> code.</p>
<p>The main complexity in sharing data between <tt class="docutils literal">ispc</tt> and C/C++ often comes
from reconciling data structures between <tt class="docutils literal">ispc</tt> code and application
code; it can be useful to declare the shared structures in <tt class="docutils literal">ispc</tt> code
and then examine the generated header file (which will have the C/C++
equivalents of them.)  For example, given a structure in <tt class="docutils literal">ispc</tt>:</p>
<pre class="literal-block">
// ispc code
struct Node {
   uniform int count;
   uniform float pos[3];
};
</pre>
<p>If the <tt class="docutils literal">Node</tt> structure is used in the parameters to an <tt class="docutils literal">export</tt> ed
function, then the header file generated by the <tt class="docutils literal">ispc</tt> compiler will
have a declaration like:</p>
<pre class="literal-block">
// C/C++ code
struct Node {
   int count;
   float pos[3];
};
</pre>
<p>Because <tt class="docutils literal">varying</tt> types have different sizes on different processor
architectures, <tt class="docutils literal">ispc</tt> prohibits any varying types from being used in
parameters to functions with the <tt class="docutils literal">export</tt> qualifier.  (<tt class="docutils literal">ispc</tt> also
prohibits passing structures that themselves have varying types as members,
etc.)  Thus, all datatypes that is shared with the application must have
the <tt class="docutils literal">uniform</tt> qualifier applied to them.  (See <a class="reference internal" href="#understanding-how-to-interoperate-with-the-application-s-data">Understanding How to
Interoperate With the Application's Data</a> for more discussion of how to
load vectors of SoA or AoSoA data from the application.)</p>
<p>While <tt class="docutils literal">ispc</tt> doesn't support pointers, there are two mechanisms to work
with pointers to arrays from the application.  First, <tt class="docutils literal">ispc</tt> passes
arrays by reference (like C), if the application has allocated an array by:</p>
<pre class="literal-block">
// C++ code
float *array = new float[count];
</pre>
<p>It can pass <tt class="docutils literal">array</tt> to a <tt class="docutils literal">ispc</tt> function defined as:</p>
<pre class="literal-block">
export void foo(uniform float array[], uniform int count)
</pre>
<p>(Though the pointer must be aligned to the compilation target's natural
vector width; see the discussion of alignment restrictions in <a class="reference internal" href="#data-alignment-and-aliasing">Data
Alignment and Aliasing</a> and the aligned allocation routines in
<tt class="docutils literal">examples/options/options.cpp</tt> for example.)</p>
<p>Similarly, <tt class="docutils literal">struct</tt> s from the application can have embedded pointers.
This is handled with similar <tt class="docutils literal">[]</tt> syntax:</p>
<pre class="literal-block">
// C code
struct Foo {
    float *foo, *bar;
};
</pre>
<p>On the <tt class="docutils literal">ispc</tt> side, the corresponding <tt class="docutils literal">struct</tt> declaration is:</p>
<pre class="literal-block">
// ispc
struct Foo {
    uniform float foo[], bar[];
};
</pre>
<p>There are two subtleties related to data layout to be aware of.  First, the
C++ specification doesn't define the size or memory layout of <tt class="docutils literal">bool</tt> s.
Therefore, it's dangerous to share <tt class="docutils literal">bool</tt> values in memory between
<tt class="docutils literal">ispc</tt> code and C/C++ code.</p>
<p>Second, <tt class="docutils literal">ispc</tt> stores <tt class="docutils literal">uniform</tt> short-vector types in memory with their
first element at the machine's natural vector alignment (i.e. 16 bytes for
a target that is using Intel® SSE, and so forth.)  This implies that these
types will have different layout on different compilation targets.  As
such, applications should in general avoid accessing <tt class="docutils literal">uniform</tt> short
vector types from C/C++ application code if possible.</p>
</div>
<div class="section" id="data-alignment-and-aliasing">
<h2>Data Alignment and Aliasing</h2>
<p>There are two important constraints that must be adhered to when passing
pointers from the application to <tt class="docutils literal">ispc</tt> programs.</p>
<p>The first constraint is alignment: any pointers from the host program that
are passed to <tt class="docutils literal">ispc</tt> must be aligned to natural vector alignment of
system--for example, 16 byte alignment on a target that supports Intel®
SSE, 32-byte on an Intel® AVX target.  If this constraint isn't met, the
program may abort at runtime with an unaligned memory access error.</p>
<p>For example, in a <tt class="docutils literal">ispc</tt> function with the following declaration:</p>
<pre class="literal-block">
export void foo(uniform float in[], uniform float out[],
                int count);
</pre>
<p>If the application is passing stack-allocated arrays for <tt class="docutils literal">in</tt> and
<tt class="docutils literal">out</tt>, these C/C++ compiler must be told to align these arrays.</p>
<pre class="literal-block">
// MSVC, SSE target
__declspec(align(16)) float in[16], out[16];
foo(in, out, 16);
</pre>
<p>With the gcc/clang compilers, the syntax for providing alignment is
slightly different:</p>
<pre class="literal-block">
float x[16] __attribute__ ((__align__(16)));
foo(in, out, 16);
</pre>
<p>If the data being passed is dynamically allocated, the appropriate system
aligned memory allocation routine should be used to allocate it (for
example, <tt class="docutils literal">_aligned_malloc()</tt> with Windows*, <tt class="docutils literal">memalign()</tt> with
Linux*; see the <tt class="docutils literal">AllocAligned()</tt> function in <tt class="docutils literal">examples/rt/rt.cpp</tt> for
an example.)</p>
<p>It is also required that it be valid to read memory at the first element of
any array that is passed to <tt class="docutils literal">ispc</tt>.  In practice, this should just
happen naturally, but it does mean that it is illegal to pass a <tt class="docutils literal">NULL</tt>
pointer as a parameter to a <tt class="docutils literal">ispc</tt> function called from the application.</p>
<p>The second key constraint is that pointers and references in <tt class="docutils literal">ispc</tt>
programs must not alias.  The <tt class="docutils literal">ispc</tt> compiler assumes that different
pointers can't end up pointing to the same memory location, either due to
having the same initial value, or through array indexing in the program as
it executed.</p>
<p>This aliasing constraint also applies to <tt class="docutils literal">reference</tt> parameters to
functions.  Given a function like:</p>
<pre class="literal-block">
void func(reference int a, reference int b) {
    a = 0;
    if (b == 0) { ... }
}
</pre>
<p>Then if the same variable must not be passed to <tt class="docutils literal">func()</tt>.  This is
another case of aliasing, and if the caller calls the function as <tt class="docutils literal">func(x,
x)</tt>, it's not guaranteed that the <tt class="docutils literal">if</tt> test will evaluate to true, due
to the compiler's requirement of no aliasing.</p>
<p>(In the future, <tt class="docutils literal">ispc</tt> will have the ability to work with unaligned
memory as well as have a mechanism to indicate that pointers may alias.)</p>
</div>
</div>
<div class="section" id="using-ispc-effectively">
<h1>Using ISPC Effectively</h1>
<div class="section" id="restructuring-existing-programs-to-use-ispc">
<h2>Restructuring Existing Programs to Use ISPC</h2>
<p><tt class="docutils literal">ispc</tt> is designed to enable you to incorporate
SPMD parallelism into existing code with minimal modification; features
like the ability to share memory and data structures betwen C/C++ and
<tt class="docutils literal">ispc</tt> code and the ability to directly call back and forth between
<tt class="docutils literal">ispc</tt> and C/C++ are motivated by this.  These features also make it
easy to incrementally transform a program to use <tt class="docutils literal">ispc</tt>; the most
computationally-intensive localized parts of the computation can be
transformed into <tt class="docutils literal">ispc</tt> code while the remainder of the system is left
as is.</p>
<p>For a given section of code to be transitioned to run in <tt class="docutils literal">ispc</tt>, the
next question is how to parallelize the computation.  Generally, there will
be obvious loops inside which a large amount of computation is done (&quot;for
each ray&quot;, &quot;for each pixel&quot;, etc.)  Mapping these to the SPMD computational
style is often effective.</p>
<p>Carefully choose how to do the exact mapping of computation to SPMD program
instances.  This choice can impact the mix of gather/scatter memory access
versus coherent memory access, for example.  (See more on this in the
section <a class="reference internal" href="#gather-and-scatter">Gather and Scatter</a> below.)  This decision can also impact the
coherence of control flow across the running SPMD program instances, which
can also have a significant effect on performance; in general, creating
groups of work that will tend to do similar computation across the SPMD
program instances improves performance.</p>
</div>
<div class="section" id="understanding-how-to-interoperate-with-the-application-s-data">
<h2>Understanding How to Interoperate With the Application's Data</h2>
<p>One of <tt class="docutils literal">ispc</tt>'s key goals is to be able to interoperate with the
application's data, in whatever layout it is stored in.  You don't need to
worry about reformatting of data or the overhead of a driver model that
abstracts the data layout.  This section illustrates some of the
alternatives with a simple example of computing the length of a large
number of vectors.</p>
<p>Consider for starters a <tt class="docutils literal">Vector</tt> data-type, defined in C as:</p>
<pre class="literal-block">
struct Vector { float x, y, z; };
</pre>
<p>We might have (still in C) an array of <tt class="docutils literal">Vector</tt> s defined like this:</p>
<pre class="literal-block">
Vector vectors[1024];
</pre>
<p>This is called an &quot;array of structures&quot; (AoS) layout.  To compute the
lengths of these vectors in parallel, you can write <tt class="docutils literal">ispc</tt> code like
this:</p>
<pre class="literal-block">
export void length(Vector vectors[1024], uniform float len[]) {
    for (uniform int i = 0; i &lt; 1024; i += programCount) {
        int index = i+programIndex;
        float x = vectors[index].x;
        float y = vectors[index].y;
        float z = vectors[index].z;
        float l = sqrt(x*x + y*y + z*z);
        len[index] = l;
    }
}
</pre>
<p>The <tt class="docutils literal">vectors</tt> array has been indexed using <tt class="docutils literal">programIndex</tt> in
order to &quot;peel off&quot; <tt class="docutils literal">programCount</tt> worth of values to compute the length
of each time through the loop.</p>
<p>The problem with this implementation is that the indexing into the array of
structures, <tt class="docutils literal"><span class="pre">vectors[index].x</span></tt> is relatively expensive.  On a target
machine that supports four-wide Intel® SSE, this turns into four loads of
single <tt class="docutils literal">float</tt> values from non-contiguous memory locations, which are
then packed into a four-wide register corresponding to <tt class="docutils literal">float x</tt>.  Once the
values are loaded into the local <tt class="docutils literal">x</tt>, <tt class="docutils literal">y</tt>, and <tt class="docutils literal">z</tt> variables,
SIMD-efficient computation can proceed; getting to that point is
relatively inefficient.</p>
<p>An alternative would be the &quot;structure of arrays&quot; (SoA) layout.  In C, the
data would be declared as:</p>
<pre class="literal-block">
float x[1024], y[1024], z[1024];
</pre>
<p>The <tt class="docutils literal">ispc</tt> code might be:</p>
<pre class="literal-block">
export void length(uniform float x[1024], uniform float y[1024],
                   uniform float z[1024], uniform float len[]) {
    for (uniform int i = 0; i &lt; 1024; i += programCount) {
        int index = i+programIndex;
        float xx = x[index];
        float yy = y[index];
        float zz = z[index];
        float l = sqrt(xx*xx + yy*yy + zz*zz);
        len[index] = l;
    }
}
</pre>
<p>In this example, the loads into <tt class="docutils literal">xx</tt>, <tt class="docutils literal">yy</tt>, and <tt class="docutils literal">zz</tt> are single
vector loads of <tt class="docutils literal">programCount</tt> values into the corresponding registers.
This processing is more efficient than the multiple scalar loads that are
required with the AoS layout above.</p>
<p>A final alternative is &quot;array of structures of arrays&quot; (AoSoA), a hybrid
between these two.  A structure is declared that stores a small number of
<tt class="docutils literal">x</tt>, <tt class="docutils literal">y</tt>, and <tt class="docutils literal">z</tt> values in contiguous memory locations:</p>
<pre class="literal-block">
struct Vector16 {
    float x[16], y[16], z[16];
};
</pre>
<p>The <tt class="docutils literal">ispc</tt> code has an outer loop over <tt class="docutils literal">Vector16</tt> elements and
then an inner loop that peels off values from the element members:</p>
<pre class="literal-block">
#define N_VEC (1024/16)
export void length(Vector16 v[N_VEC], uniform float len[]) {
    for (uniform int i = 0; i &lt; N_VEC; ++i) {
        for (uniform int j = 0; j &lt; 16; j += programCount) {
            int index = j + programIndex;
            float x = v[i].x[index];
            float y = v[i].y[index];
            float z = v[i].z[index];
            float l = sqrt(x*x + y*y + z*z);
            len[index] = l;
        }
    }
}
</pre>
<p>(This code assumes that <tt class="docutils literal">programCount</tt> divides 16 equally.  See below for
discussion of the more general case.)  One advantage of the AoSoA layout is
that the memory accesses to load values are to nearby memory locations,
where as with SoA, each of the three loads above is to locations separated
by a few thousand bytes.  Thus, AoSoA can be more cache friendly.  For
structures with many members, this difference can lead to a substantial
improvement.</p>
<p><tt class="docutils literal">ispc</tt> can also efficiently process data in AoSoA layout where the inner
array length is less than the machine vector width.  For example, consider
doing computation with this AoSoA structure definition on a machine with an
8-wide vector unit (for example, an Intel® AVX target):</p>
<pre class="literal-block">
struct Vector4 {
    float x[4], y[4], z[4];
};
</pre>
<p>The <tt class="docutils literal">ispc</tt> code to process this loads elements four at a time from
<tt class="docutils literal">Vector4</tt> instances until it has a full <tt class="docutils literal">programCount</tt> number of
elements to work with and then proceeds with the computation.</p>
<pre class="literal-block">
#define N_VEC (1024/4)
export void length(Vector4 v[N_VEC], uniform float len[]) {
    for (uniform int i = 0; i &lt; N_VEC; i += programCount / 4) {
        float x, y, z;
        for (uniform int j = 0; j &lt; programCount / 4; ++j) {
            if (programIndex &gt;= 4 * j &amp;&amp;
                programIndex &lt;  4 * (j+1)) {
                int index = (programIndex &amp; 0x3);
                x = v[i+j].x[index];
                y = v[i+j].y[index];
                z = v[i+j].z[index];
            }
        }
        float l = sqrt(x*x + y*y + z*z);
        len[4*i + programIndex] = l;
    }
}
</pre>
</div>
<div class="section" id="communicating-between-spmd-program-instances">
<h2>Communicating Between SPMD Program Instances</h2>
<p>The <tt class="docutils literal">programIndex</tt> built-in variable (see <a class="reference internal" href="#mapping-data-to-program-instances">Mapping Data To Program
Instances</a>) can be used to communicate between the set of executing
program instances.  Consider the following code, which shows all of the
program instances writing into unique locations in an array.</p>
<pre class="literal-block">
float x = ...;
uniform float allX[programCount];
allX[programIndex] = x;
</pre>
<p>In this code, a program instance that reads <tt class="docutils literal">allX[0]</tt> finds the value of
<tt class="docutils literal">x</tt> that was computed by the first of the running program instances, and
so forth.  Program instances can communicate with their neighbor instances
with indexing like <tt class="docutils literal"><span class="pre">allX[(programIndex+1)%programCount]</span></tt>.</p>
</div>
<div class="section" id="gather-and-scatter">
<h2>Gather and Scatter</h2>
<p>The CPU is a poor fit for SPMD execution in some ways, the worst of which
is handling of general memory reads and writes from SPMD program instances.
For example, in a &quot;simple&quot; array index:</p>
<pre class="literal-block">
int i = ....;
uniform float x[10] = { ... };
float f = x[i];
</pre>
<p>Since the index <tt class="docutils literal">i</tt> is a varying value, the various SPMD program
instances will in general be reading different locations in the array
<tt class="docutils literal">x</tt>.  Because the CPU doesn't have a gather instruction, the <tt class="docutils literal">ispc</tt>
compiler has to serialize these memory reads, performing a separate memory
load for each running program instance, packing the result into <tt class="docutils literal">f</tt>.
(And the analogous case would happen for a write into <tt class="docutils literal">x[i]</tt>.)</p>
<p>In many cases, gathers like these are unavoidable; the running program
instances just need to access incoherent memory locations.  However, if the
array index <tt class="docutils literal">i</tt> could actually be declared and used as a <tt class="docutils literal">uniform</tt>
variable, the resulting array index is substantially more
efficient.  This is another case where using <tt class="docutils literal">uniform</tt> whenever applicable
is of benefit.</p>
<p>In some cases, the <tt class="docutils literal">ispc</tt> compiler is able to deduce that the memory
locations accessed are either all the same or are uniform.  For example,
given:</p>
<pre class="literal-block">
uniform int x = ...;
int y = x;
return array[y];
</pre>
<p>The compiler is able to determine that all of the program instances are
loading from the same location, even though <tt class="docutils literal">y</tt> is not a <tt class="docutils literal">uniform</tt>
variable.  In this case, the compiler will transform this load to a regular vector
load, rather than a general gather.</p>
<p>Sometimes the running program instances will access a
linear sequence of memory locations; this happens most frequently when
array indexing is done based on the built-in <tt class="docutils literal">programIndex</tt> variable.  In
many of these cases, the compiler is also able to detect this case and then
do a vector load.  For example, given:</p>
<pre class="literal-block">
uniform int x = ...;
return array[2*x + programIndex];
</pre>
<p>A regular vector load is done from array, starting at offset <tt class="docutils literal">2*x</tt>.</p>
</div>
<div class="section" id="low-level-vector-tricks">
<h2>Low-level Vector Tricks</h2>
<p>Many low-level Intel® SSE coding constructs can be implemented in <tt class="docutils literal">ispc</tt>
code.  For example, the following code efficiently reverses the sign of the
given values.</p>
<pre class="literal-block">
float flipsign(float a) {
    unsigned int i = intbits(a);
    i ^= 0x80000000;
    return floatbits(i);
}
</pre>
<p>This code compiles down to a single XOR instruction.</p>
</div>
<div class="section" id="debugging">
<h2>Debugging</h2>
<p>Support for debugging in <tt class="docutils literal">ispc</tt> is in progress.  On Linux* and Mac
OS*, the <tt class="docutils literal"><span class="pre">-g</span></tt> command-line flag can be supplied to the compiler,
which causes it to generate debugging symbols.  Running <tt class="docutils literal">ispc</tt> programs
in the debugger, setting breakpoints, printing out variables and the like
all generally works, though there is occasional unexpected behavior.</p>
<p>Another option for debugging (the only current option on Windows*) is
to use the <tt class="docutils literal">print</tt> statement for <tt class="docutils literal">printf()</tt>
style debugging.  You can also use the ability to call back to
application code at particular points in the program, passing a set of
variable values to be logged or otherwise analyzed from there.</p>
</div>
<div class="section" id="the-fast-math-option">
<h2>The &quot;Fast math&quot; Option</h2>
<p><tt class="docutils literal">ispc</tt> has a <tt class="docutils literal"><span class="pre">--fast-math</span></tt> command-line flag that enables a number of
optimizations that may be undesirable in code where numerical preceision is
critically important.  For many graphics applications, the
approximations may be acceptable.  The following two optimizations are
performed when <tt class="docutils literal"><span class="pre">--fast-math</span></tt> is used.  By default, the <tt class="docutils literal"><span class="pre">--fast-math</span></tt>
flag is off.</p>
<ul class="simple">
<li>Expressions like <tt class="docutils literal">x / y</tt>, where <tt class="docutils literal">y</tt> is a compile-time constant, are
transformed to <tt class="docutils literal">x * <span class="pre">(1./y)</span></tt>, where the inverse value of <tt class="docutils literal">y</tt> is
precomputed at compile time.</li>
<li>Expressions like <tt class="docutils literal">x / y</tt>, where <tt class="docutils literal">y</tt> is not a compile-time constant,
are transformed to <tt class="docutils literal">x * rcp(y)</tt>, where <tt class="docutils literal">rcp()</tt> maps to the
approximate reciprocal instruction from the standard library.</li>
</ul>
</div>
<div class="section" id="inline-aggressively">
<h2>&quot;Inline&quot; Aggressively</h2>
<p>Inlining functions aggressively is generally beneficial for performance
with <tt class="docutils literal">ispc</tt>.  Definitely use the <tt class="docutils literal">inline</tt> qualifier for any short
functions (a few lines long), and experiment with it for longer functions.</p>
</div>
<div class="section" id="small-performance-tricks">
<h2>Small Performance Tricks</h2>
<p>Performance is slightly improved by declaring variables at the same block
scope where they are first used.  For example, in code like the
following, if the lifetime of <tt class="docutils literal">foo</tt> is only within the scope of the
<tt class="docutils literal">if</tt> clause, write the code like this:</p>
<pre class="literal-block">
float func() {
    ....
    if (x &lt; y) {
        float foo;
        ... use foo ...
    }
}
</pre>
<p>Try not to write code as:</p>
<pre class="literal-block">
float func() {
    float foo;
    ....
    if (x &lt; y) {
        ... use foo ...
    }
}
</pre>
<p>Doing so can reduce the amount of masked store instructions that the
compiler needs to generate.</p>
</div>
<div class="section" id="instrumenting-your-ispc-programs">
<h2>Instrumenting Your ISPC Programs</h2>
<p><tt class="docutils literal">ispc</tt> has an optional instrumentation feature that can help you
understand performance issues.  If a program is compiled using the
<tt class="docutils literal"><span class="pre">--instrument</span></tt> flag, the compiler emits calls to a function with the
following signature at various points in the program (for
example, at interesting points in the control flow, when scatters or
gathers happen.)</p>
<pre class="literal-block">
extern &quot;C&quot; {
    void ISPCInstrument(const char *fn, const char *note,
                        int line, int mask);
}
</pre>
<p>This function is passed the file name of the <tt class="docutils literal">ispc</tt> file running, a short
note indicating what is happening, the line number in the source file, and
the current mask of active SPMD program lanes.  You must provide an
implementation of this function and link it in with your application.</p>
<p>For example, when the <tt class="docutils literal">ispc</tt> program runs, this function might be called
as follows:</p>
<pre class="literal-block">
ISPCInstrument(&quot;foo.ispc&quot;, &quot;function entry&quot;, 55, 0xf);
</pre>
<p>This call indicates that at the currently executing program has just
entered the function defined at line 55 of the file <tt class="docutils literal">foo.ispc</tt>, with a
mask of all lanes currently executing (assuming a four-wide Intel® SSE
target machine).</p>
<p>For a fuller example of the utility of this functionality, see
<tt class="docutils literal">examples/aobench_instrumented</tt> in the <tt class="docutils literal">ispc</tt> distribution.  Ths
example includes an implementation of the <tt class="docutils literal">ISPCInstrument</tt> function that
collects aggregate data about the program's execution behavior.</p>
<p>When running this example, you will want to direct to the <tt class="docutils literal">ao</tt> executable
to generate a low resolution image, because the instrumentation adds
substantial execution overhead.  For example:</p>
<pre class="literal-block">
% ./ao 1 32 32
</pre>
<p>After the <tt class="docutils literal">ao</tt> program exits, a summary report along the following lines
will be printed.  In the first few lines, you can see how many times a few
functions were called, and the average percentage of SIMD lanes that were
active upon function entry.</p>
<pre class="literal-block">
ao.ispc(0067) - function entry: 342424 calls (0 / 0.00% all off!), 95.86% active lanes
ao.ispc(0067) - return: uniform control flow: 342424 calls (0 / 0.00% all off!), 95.86% active lanes
ao.ispc(0071) - function entry: 1122 calls (0 / 0.00% all off!), 97.33% active lanes
ao.ispc(0075) - return: uniform control flow: 1122 calls (0 / 0.00% all off!), 97.33% active lanes
ao.ispc(0079) - function entry: 10072 calls (0 / 0.00% all off!), 45.09% active lanes
ao.ispc(0088) - function entry: 36928 calls (0 / 0.00% all off!), 97.40% active lanes
...
</pre>
</div>
</div>
<div class="section" id="disclaimer-and-legal-information">
<h1>Disclaimer and Legal Information</h1>
<p>INFORMATION IN THIS DOCUMENT IS PROVIDED IN CONNECTION WITH INTEL(R) PRODUCTS.
NO LICENSE, EXPRESS OR IMPLIED, BY ESTOPPEL OR OTHERWISE, TO ANY INTELLECTUAL
PROPERTY RIGHTS IS GRANTED BY THIS DOCUMENT. EXCEPT AS PROVIDED IN INTEL'S TERMS
AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER,
AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE
OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A
PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT
OR OTHER INTELLECTUAL PROPERTY RIGHT.</p>
<p>UNLESS OTHERWISE AGREED IN WRITING BY INTEL, THE INTEL PRODUCTS ARE NOT DESIGNED
NOR INTENDED FOR ANY APPLICATION IN WHICH THE FAILURE OF THE INTEL PRODUCT COULD
CREATE A SITUATION WHERE PERSONAL INJURY OR DEATH MAY OCCUR.</p>
<p>Intel may make changes to specifications and product descriptions at any time,
without notice. Designers must not rely on the absence or characteristics of any
features or instructions marked &quot;reserved&quot; or &quot;undefined.&quot; Intel reserves these
for future definition and shall have no responsibility whatsoever for conflicts
or incompatibilities arising from future changes to them. The information here
is subject to change without notice. Do not finalize a design with this
information.</p>
<p>The products described in this document may contain design defects or errors
known as errata which may cause the product to deviate from published
specifications. Current characterized errata are available on request.</p>
<p>Contact your local Intel sales office or your distributor to obtain the latest
specifications and before placing your product order.</p>
<p>Copies of documents which have an order number and are referenced in this
document, or other Intel literature, may be obtained by calling 1-800-548-4725,
or by visiting Intel's Web Site.</p>
<p>Intel processor numbers are not a measure of performance. Processor numbers
differentiate features within each processor family, not across different
processor families. See <a class="reference external" href="http://www.intel.com/products/processor_number">http://www.intel.com/products/processor_number</a> for
details.</p>
<p>BunnyPeople, Celeron, Celeron Inside, Centrino, Centrino Atom,
Centrino Atom Inside, Centrino Inside, Centrino logo, Core Inside, FlashFile,
i960, InstantIP, Intel, Intel logo, Intel386, Intel486, IntelDX2, IntelDX4,
IntelSX2, Intel Atom, Intel Atom Inside, Intel Core, Intel Inside,
Intel Inside logo, Intel. Leap ahead., Intel. Leap ahead. logo, Intel NetBurst,
Intel NetMerge, Intel NetStructure, Intel SingleDriver, Intel SpeedStep,
Intel StrataFlash, Intel Viiv, Intel vPro, Intel XScale, Itanium,
Itanium Inside, MCS, MMX, Oplus, OverDrive, PDCharm, Pentium, Pentium Inside,
skoool, Sound Mark, The Journey Inside, Viiv Inside, vPro Inside, VTune, Xeon,
and Xeon Inside are trademarks of Intel Corporation in the U.S. and other
countries.</p>
<ul class="simple">
<li>Other names and brands may be claimed as the property of others.</li>
</ul>
<p>Copyright(C) 2011, Intel Corporation. All rights reserved.</p>
</div>
<div class="section" id="optimization-notice">
<h1>Optimization Notice</h1>
<p>Intel compilers, associated libraries and associated development tools may
include or utilize options that optimize for instruction sets that are
available in both Intel and non-Intel microprocessors (for example SIMD
instruction sets), but do not optimize equally for non-Intel
microprocessors.  In addition, certain compiler options for Intel
compilers, including some that are not specific to Intel
micro-architecture, are reserved for Intel microprocessors.  For a detailed
description of Intel compiler options, including the instruction sets and
specific microprocessors they implicate, please refer to the &quot;Intel
Compiler User and Reference Guides&quot; under &quot;Compiler Options.&quot;  Many library
routines that are part of Intel compiler products are more highly optimized
for Intel microprocessors than for other microprocessors.  While the
compilers and libraries in Intel compiler products offer optimizations for
both Intel and Intel-compatible microprocessors, depending on the options
you select, your code and other factors, you likely will get extra
performance on Intel microprocessors.</p>
<p>Intel compilers, associated libraries and associated development tools may
or may not optimize to the same degree for non-Intel microprocessors for
optimizations that are not unique to Intel microprocessors.  These
optimizations include Intel® Streaming SIMD Extensions 2 (Intel® SSE2),
Intel® Streaming SIMD Extensions 3 (Intel® SSE3), and Supplemental
Streaming SIMD Extensions 3 (Intel SSSE3) instruction sets and other
optimizations.  Intel does not guarantee the availability, functionality,
or effectiveness of any optimization on microprocessors not manufactured by
Intel.  Microprocessor-dependent optimizations in this product are intended
for use with Intel microprocessors.</p>
<p>While Intel believes our compilers and libraries are excellent choices to
assist in obtaining the best performance on Intel and non-Intel
microprocessors, Intel recommends that you evaluate other compilers and
libraries to determine which best meet your requirements.  We hope to win
your business by striving to offer the best performance of any compiler or
library; please let us know if you find we do not.</p>
      </div>
    </div>
    <div class="clearfix"></div>
    <div id="footer"> &copy; 2011 <strong>Intel Corporation</strong> | Valid <a href="http://validator.w3.org/check?uri=referer">XHTML</a> | <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a> | ClearBlue  by: <a href="http://www.themebin.com/">ThemeBin</a>
      <!-- Please Do Not remove this link, thank u -->
      </div>
  </div>
  <!-- End Wrap2 -->
</div>
</div>
</body>
</html>
